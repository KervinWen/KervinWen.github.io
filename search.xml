<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式-2</title>
      <link href="/2022/01/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-2/"/>
      <url>/2022/01/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-2/</url>
      
        <content type="html"><![CDATA[<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><blockquote><p>这部分有4个方面<br>1.<strong>分组</strong><br>2.<strong>回溯引用</strong><br>3.<strong>前后预先查找（零宽度断言）</strong><br>4.贪婪与懒惰匹配</p></blockquote><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>采用<code>( )</code>进行匹配分组<br><br></p><h2 id="回溯引用"><a href="#回溯引用" class="headerlink" title="回溯引用"></a>回溯引用</h2><p>简而言之，就是在子表达式匹配结果的基础上，再次进行匹配</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>使用方式如下：<br><code>/1</code>,<code>/2</code><br>分别表示引用前面的 <strong>第1、2个</strong> 子表达式<br><code>/0</code>代表整个Regx </p><div class="note flat"><p>/(a)(b)\1/<br>描述：相当于匹配aba字符串<br>结果：<br>abc|abbc|<strong>aba</strong></p></div><br><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>使用方式类似：<br><code>$1</code>,<code>$2</code><br>分别表示引用前面的<strong>第1、2个子表达式的结果</strong><br><code>$0</code>或<code>$&</code>代表整个Regx匹配结果</p><div class="note flat"><p>需要注意的是：<br>直接用<strong>newSubStr</strong>替换时，整体应该用 <strong>$&amp;</strong> 表示<br>使用<strong>function</strong>时，应该使用 <strong>$0</strong></p></div><p>字符串替换函数,该函数返回一个新字符串<br>str.replace(regexp|substr, <strong>newSubStr|function</strong>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&quot;18:78:45:222&quot;</span></span><br><span class="line"><span class="comment">//匹配该特定时间戳</span></span><br><span class="line"><span class="keyword">let</span> reg=<span class="regexp">/^(.&#123;5,8&#125;):(.*)$/g</span></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="keyword">let</span> result</span><br><span class="line">str.replace(reg, <span class="function">(<span class="params">$<span class="number">0</span></span>)=&gt;</span>&#123;</span><br><span class="line">    result=$<span class="number">0</span>+<span class="string">&#x27;111&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><br><h3 id="非捕获正则"><a href="#非捕获正则" class="headerlink" title="非捕获正则"></a>非捕获正则</h3><p>如果不想子字符串被引用的话，我们可以<strong>让它不被捕获</strong><br>那么它就不会单独出现在结果组中，避免内存的浪费</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">let</span> result=str.replace(<span class="regexp">/(ab)(?:c)/g</span>,<span class="string">&#x27;$&amp;:$1:&amp;$2:&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">//abc:ab:$2</span></span><br><span class="line"><span class="comment">//c并没有被单独捕获储存为“$2”的值，但是整体的结果组“$&amp;”中还是有它的</span></span><br></pre></td></tr></table></figure><br><h2 id="前后预查（零宽度断言）（Lookaround）"><a href="#前后预查（零宽度断言）（Lookaround）" class="headerlink" title="前后预查（零宽度断言）（Lookaround）"></a>前后预查（零宽度断言）（Lookaround）</h2><p>包括：</p><ol><li>前向查找（Lookahead）:描述<strong>目标前面</strong>的内容</li><li>后向查找（Lookbehind）：描述<strong>目标后面</strong>的内容</li></ol><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>Lookaround,观察周边的环境</p><p>我们可以通过描述目标内容的<strong>前后内容</strong>，来匹配它<br>在后文，我称这种内容为<strong>环境内容</strong><br>简单来说，这就是<strong>相对定位</strong>的一种方式</p><p>断言：一个为真的描述<br>零宽度：描述中的<strong>环境内容</strong>实际并<strong>不作为匹配结果</strong>返回，即不会被捕获。<br>【在语文上，该描述就是目标内容的定语】</p><!-- ### 前向查找 (Lookahead)1. （正）前向查找<div class="note flat"><p>/\w+(?=ish)/<br>    描述：查找&gt;=0个单词字符。这些字符组成的字符串的后缀为“ish”<br>    即【查找后缀为“ish”的单词的前缀】<br>    结果：<strong>fool</strong>ish and <strong>child</strong>ish.</p></div><ol start="2"><li>负前向查找<div class="note flat"><p>/\b(\w(?!ish))+\b/<br>    描述：查找&gt;0个后缀不为“ish”的单词字符。这些字符组成被单词边界包裹的字符串<br>    即【查找后缀不为“ish”的单词】<br>    结果：foolish <strong>and</strong> childish.</p></div></li></ol><h3 id="后向查找-Lookbehind"><a href="#后向查找-Lookbehind" class="headerlink" title="后向查找 (Lookbehind)"></a>后向查找 (Lookbehind)</h3><ol><li>（正）后向查找<div class="note flat"><p>/(?&lt;=fool)\w+\b/<br>    描述：查找&gt;=0个单词字符。这些字符组成的字符串的前缀为“fool”，它的后面为单词边界<br>    即【查找前缀为“fool”的单词的后缀】<br>    结果：fool<strong>ish</strong> and childish.</p></div></li><li>负后向查找<div class="note flat"><p>/\b((?&lt;=fool)\w)+\b/<br>    描述：查找&gt;=0个前缀不为“fool”的单词字符，这些字符组成被单词边界包裹的字符串<br>    即【查找前缀不为“fool”的单词】<br>    结果：fool<strong>ish</strong> and childish.</p></div> --><br></li></ol><h3 id="正-查找"><a href="#正-查找" class="headerlink" title="(正)查找"></a>(正)查找</h3><p>对描述的前、后内容持<strong>肯定</strong>态度</p><ol><li><p>(正)前向查找</p><div class="note flat"><p>/\w+(?=ish)/<br>    描述：查找&gt;=1个单词字符。这些字符组成的字符串的后缀为“ish”<br>    即【查找后缀为“ish”的单词的前缀】<br>    结果：<strong>fool</strong>ish and <strong>child</strong>ish.</p></div></li><li><p>(正)后向查找</p><div class="note flat"><p>/(?&lt;=fool)\w+\b/<br>    描述：查找&gt;=1个单词字符。这些字符组成的字符串的前缀为“fool”，它的后面为单词边界<br>    即【查找前缀为“fool”的单词的后缀】<br>    结果：fool<strong>ish</strong> and childish.</p></div><br></li></ol><h3 id="负查找"><a href="#负查找" class="headerlink" title="负查找"></a>负查找</h3><p>对描述的环境内容持<strong>否定</strong>态度</p><ol><li><p>负前向查找</p><div class="note flat"><p>/\b(\w(?!ish))+\b/<br>    描述：查找&gt;1个后缀<strong>【不】</strong>为“ish”的单词字符。这些字符组成被单词边界包裹的字符串<br>    即【查找后缀不为“ish”的单词】<br>    结果：foolish <strong>and</strong> childish.</p></div></li><li><p>负后向查找</p><div class="note flat"><p>/\b((?&lt;=fool)\w)+\b/<br>    描述：查找&gt;=1个前缀<strong>【不】</strong>为“fool”的单词字符，这些字符组成被单词边界包裹的字符串<br>    即【查找前缀不为“fool”的单词】<br>    结果：foolish <strong>and</strong> <strong>childish</strong>.</p></div></li></ol><div class="note warning flat"><p>在<code>JavaScirpt</code>中，ES2018之前并不支持<strong>后向查找</strong><br>可以通过<strong>字符串翻转</strong>来间接完成</p></div><br><h2 id="贪婪与懒惰匹配-（Greedy-vs-Lazy-matching）"><a href="#贪婪与懒惰匹配-（Greedy-vs-Lazy-matching）" class="headerlink" title="贪婪与懒惰匹配 （Greedy vs Lazy matching）"></a>贪婪与懒惰匹配 （Greedy vs Lazy matching）</h2><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>Regx<strong>默认</strong>采用贪婪匹配：<br>匹配<strong>尽可能长</strong>的字符串</p><div class="note flat"><p>/(.*at)/<br>    描述：贪婪查找&gt;=0个除换行符之外的任意字符。这些字符组成的字符串后缀为“at”<br>    结果：<strong>The fat cat sat on the mat</strong>. </p></div><h3 id="惰性匹配"><a href="#惰性匹配" class="headerlink" title="惰性匹配"></a>惰性匹配</h3><p>我们可以采用来转为Lazy模式<br>注意区分数量指定中的<code>?</code></p><div class="note flat"><p>/(.*?at)/<br>    描述：惰性查找&gt;=0个除换行符之外的任意字符。这些字符组成的字符串后缀为“at”<br>    结果：<strong>The fat</strong> cat sat on the mat. </p></div><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基础篇掌握练习，进阶篇主要是要掌握匹配描述的思想，实际上这些思想我们在学习其他工具、学科都已经接触、熟悉过了<br>Regx是门工具语言，我们就是要学会怎么有逻辑地把自己的意思表达出来</p><p>想练习巩固的可以自行选择基础篇的开头推荐的网站<br>希望对大家有所帮助~<br>也欢迎大家畅所欲言~</p><div class="note flat"><p>参考文章：</p><ol><li><a href="https://juejin.cn/post/6844903845227659271#heading-2">正则表达式不用背</a></li><li><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md#learn-regex">Learn-Regex</a></li></ol></div><blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><!-- [articleName](url) --></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> Regx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式-1</title>
      <link href="/2021/12/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-1/"/>
      <url>/2021/12/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习一门工具时，我认为要了解以下几点：</p><ol><li>它是什么？–or–它被创造出来是为了什么目的？</li><li>它的基本组成与基础用法</li><li>它的进阶用法</li></ol><p>接下来，我会以此为大概脉络，阐述我认知中的正则表达式<br>如果有什么错误、想法，敬请各位畅所欲言！感谢~</p><p>推荐选择Regex101作为起步：</p><ul><li><a href="https://regex101.com/">Regex101</a><br>【显示匹配结果，对表达式作解释。登录后可进行quiz小测。设置中默认全局搜索&amp;多行模式，见（定位与搜索）-（标志）】</li><li><a href="https://regexper.com/">regexper</a><br>【可视化显示表达式】</li><li><a href="https://tool.oschina.net/regex#">osChina</a><br>【右侧有常用的Regx示例】<br></li></ul><h1 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h1><p>正则表达式(<strong>Regular Expression</strong>，简称Regx)，从命名我们不难猜到，它是一种<strong>描述</strong>某种<strong>规则</strong>的表达式。通过自定义规则，我们可以用它来实现字符串检索、替换的功能</p><p>据言，正则表达式起源于<strong>描述神经网络</strong>的数学模型。联系神经网络相关的知识，有助于我们更深刻地理解它的实现原理，感兴趣的同学可以深入研究</p><h1 id="基本组成与基础用法"><a href="#基本组成与基础用法" class="headerlink" title="基本组成与基础用法"></a>基本组成与基础用法</h1><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p>正则表达式的基本组成元素：<strong>普通字符与元字符</strong>(metaCharacters)。<br>普通字符：包括大小写字母和数字<br>元字符：被规定具有<strong>特殊含义</strong>的字符</p><blockquote><p>了解了正则表达式的基本组成之后<br>我们将结合一些简单的例子，边学边做，循序渐进</p></blockquote><br><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>在这个章节，我们会逐渐接触到一个个的<strong>元字符</strong><br>而在文章的末尾，我会附上文章涉及到的<strong>元字符</strong>等表格，方便大家回忆、总结以及练习</p><p>现在开始，想象我们是一个<strong>发号施令的指挥者</strong>，我们将向<strong>执行者</strong>，利用Regx这门语言工具描述一个规则，让他去为我们找到想要的字符~<br><br></p><h3 id="【明确的】单字符匹配"><a href="#【明确的】单字符匹配" class="headerlink" title="【明确的】单字符匹配"></a>【明确的】单字符匹配</h3><p>我们非常直白描述了：我们需要匹配<strong>一个普通字符a</strong></p><div class="note flat"><p>/a/<br>结果：<br>A <strong>a</strong>pple for <strong>a</strong> m<strong>a</strong>n.</p></div><p>不难发现，正则表达式是 <strong>【大小写敏感】</strong> 的<br><br></p><p>这里，我们可以提出一个问题：<br>普通字符，我们可以匹配了，那么如果我要匹配<strong>一个元字符</strong>怎么办呢？<br>这就需要请出我们的转义元字符<code>\</code>了。顾名思义，用它告诉执行者，后续的字符舍弃其<strong>本身含义</strong>，赋予<strong>另一种含义</strong></p><div class="note flat"><p>/\+/<br>描述：查找元字符+<br>结果：<br>1 <strong>+</strong> 1=2</p></div>  <br><p>转义字符，相信大家并不陌生。<br>上面我们用它将特殊字符 <code>+</code> 描述为普通字符<br>那么，如果我们用转义字符描述<strong>某些</strong>普通字符，会发生什么呢？</p><div class="note flat"><p>/\n/<br>结果：<br>A apple for a man.<strong>我是换行符\n</strong><br>Funny day.</p></div><p>这里的 <code>\n</code>就是字符编码中被赋予特殊意义的转义字符了<br><br></p><!-- 表格必须上一行为【空行】 --><!-- 利用中间的冒号，实现左、右、中对齐 --><p>类似的常见转义特殊字符有：</p><table><thead><tr><th align="left">特殊字符</th><th align="left">表达式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">换行符</td><td align="left">\n</td><td align="left"><strong>n</strong>ew line</td></tr><tr><td align="left">回车符</td><td align="left">\r</td><td align="left"><strong>r</strong>etutn</td></tr><tr><td align="left">空格符</td><td align="left">\s</td><td align="left"><strong>s</strong>pace</td></tr><tr><td align="left">水平制表符</td><td align="left">\t</td><td align="left"><strong>t</strong>ab</td></tr><tr><td align="left">垂直制表符</td><td align="left">\v</td><td align="left"><strong>v</strong>ertical</td></tr><tr><td align="left">换页符</td><td align="left">\f</td><td align="left"><strong>f</strong>rom feed</td></tr></tbody></table><br><h3 id="多字符匹配"><a href="#多字符匹配" class="headerlink" title="多字符匹配"></a>多字符匹配</h3><blockquote><p>现在，我们开始学习怎么向执行者描述多个字符</p></blockquote><p>最简单的。<strong>明确地</strong>描述一个<strong>连续的abc子串</strong></p><div class="note flat"><p>/abc/<br>结果：<br>I’ m <strong>abc</strong>君.a&amp;bc</p></div><br><p>元字符<code>( )</code>,定义<strong>子串集合</strong>，匹配该子串</p><div class="note flat"><p>/(abc)/<br>结果：<br>I’ m <strong>abc</strong>君.a&amp;bc</p></div><br><p>元字符<code>.</code>，代表除<strong>换行符之外</strong>的<strong>任意字符</strong></p><div class="note flat"><p>/. /<br>结果：<br><strong>A apple for a man.</strong> 我是换行符<br><strong>Funny day.</strong></p></div><br><p>元字符<code>[ ]</code>，定义<strong>字符种类</strong>,匹配这类字符<br>实际上，一些常见的字符种类，已经被定义好了。我会在表格中附上</p><div class="note flat"><p>/[a-c]/<br>结果：<br>I’ m <strong>abc</strong>君.<strong>a</strong>&amp;<strong>b</strong>&amp;<strong>c</strong></p></div><br><p>元字符<code>[^ ]</code>，<strong>否定的</strong>字符集合，将其<strong>除外</strong><br>需要注意的是，<code>*</code><strong>不在[]中</strong>时，含义是不同的。后续会提到</p><div class="note flat"><p>/[a-c]/<br>结果：<br><strong>I’ m</strong> abc <strong>君.</strong> a <strong>&amp;</strong> b <strong>&amp;</strong> c</p></div><br><p>他们的共同点是：描述了一个有序或无序的字符串集合。<br>理所当然的，这个集合我们又可以看作<strong>一个自定义的字符</strong>，从而进行更复杂的规则描述<br><br></p><h3 id="字符重复数量指定"><a href="#字符重复数量指定" class="headerlink" title="字符重复数量指定"></a>字符重复数量指定</h3><blockquote><p>前面，我们学会了怎么分类。<br>为了编写的简便，我们接下来学习怎么<strong>指定字符重复次数</strong></p></blockquote><br><p>元字符<code>?</code>，0或1个,<code>?</code>之前的字符</p><div class="note flat"><p>/ab?c/<br>结果：<br><strong>abc</strong>|abbc|<strong>ac</strong></p></div><br><p>元字符 <code>*</code>，&gt;=0个 </p><div class="note flat"><p>/ab*c/<br>结果：<br><strong>abc</strong>|<strong>abbc</strong>|<strong>ac</strong></p></div><br><p>元字符<code>+</code>，&gt;=1个</p><div class="note flat"><p>/ab+c/<br>结果：<br><strong>abc</strong>|<strong>abbc</strong>|ac</p></div><br><p>元字符<code>&#123;min,max&#125;</code>,指定数量范围<br>注意：用法为<code>&#123;min,&#125;</code>、<code>&#123;min,max&#125;</code>、<code>&#123;定量&#125;</code>【为闭合区间】</p><div class="note flat"><p>/ab{1,}c/<br>结果：<br><strong>abc</strong>|<strong>abbc</strong>|ac</p></div><br><h3 id="定位与修正"><a href="#定位与修正" class="headerlink" title="定位与修正"></a>定位与修正</h3><blockquote><p>上面我们已经了解了怎么描述我们要的<strong>字符的样子</strong></p><p>接下来，我们进入较为具体的应用场景：</p><ul><li>在<strong>文本</strong>中描述匹配字符的<strong>位置</strong></li><li>以及对匹配<strong>结果</strong>进行<strong>修正</strong></li></ul><p>内容包括以下3点：</p><ol><li>单词边界【】</li><li>字符串边界</li><li>标志</li></ol></blockquote><br><h4 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h4><p>Regx：<code>\b</code> —&gt;<strong>b</strong>oundary</p><div class="note flat"><p>/\bour\b/<br>结果：<br><strong>our</strong> hotel during happy hours</p></div><br><h4 id="非单词边界"><a href="#非单词边界" class="headerlink" title="非单词边界"></a>非单词边界</h4><p>Regx：<code>\B</code></p><div class="note flat"><p>/\Bour\B/<br>结果：<br>our hotel during happy h<strong>our</strong>s</p></div><br><h4 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h4><p>Regx：<code>^</code> —-&gt;匹配字符串首开始检索</p><div class="note flat"><p>/^me/<br>结果：<br><strong>me</strong> and you and me</p></div><p>Regx： <code>$</code> —-&gt; 匹配字符串尾开始检索</p><div class="note flat"><p>/me$/<br>结果：<br>me and you and <strong>me</strong></p></div><br><h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><p>标志（模式<strong>修正</strong>符），顾名思义，用于<strong>修正</strong>模式匹配的<strong>结果</strong>。可以任意组合。</p><p>标志：<code>m</code> —-&gt; <strong>m</strong>utiline,多行模式<br>前面提到的<code>^</code>和<code>$</code>用于指定检索起点<strong>字符串</strong>首、末<br>当设置了标志<code>m</code>，<code>$</code>也匹配字符<code>\n</code>和<code>\r</code></p><p>所以我们想Regx在<strong>每行</strong>的首末生效，就需要用到<code>m</code></p><div class="note flat"><p><strong>“/end(.)?$/”</strong><br>描述：匹配<strong>字符串末尾</strong>的“end+后面可选除换行符的任意字符”<br>结果：<br>How do  you friend<br>intend<br>to spend<br>the week<strong>end.</strong></p><p>多行模式：<br><strong>“/end(.)?$/m”</strong><br>描述：匹配<strong>每行行尾</strong>的“end+后面可选除换行符的任意字符”<br>结果：<br>How do  you fri<strong>end</strong><br>int<strong>end</strong><br>to sp<strong>end</strong><br>the week<strong>end.</strong></p><p>其它标志的用法相同</p></div><p>标志：<strong>i</strong> —-&gt; <strong>i</strong>gnore case，忽略大小写</p><p>标志：<strong>g</strong> —-&gt; <strong>g</strong>lobal search，全局搜索<br>需要明确的是：<br>非全局搜索时，Regx匹配<strong>一次</strong>，就会停止并返回结果<br>全局搜索，则会执行<strong>多次</strong>匹配，返回所有结果<br><br></p><blockquote><p>感谢你能看到这里，希望对你有所帮助<br>基础的都基本讲完了，相信写些简单的字符匹配，大家也能心中有数了</p><p>Regx中，<strong>有些常用的字符集匹配是已经集成的了</strong>，我会在每篇文章结尾附上表格</p><p>下一篇将继续探讨如何处理更复杂的Regx</p></blockquote><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="常见转义字符"><a href="#常见转义字符" class="headerlink" title="常见转义字符"></a>常见转义字符</h2><table><thead><tr><th align="left">特殊字符</th><th align="left">表达式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">换行符</td><td align="left">\n</td><td align="left"><strong>n</strong>ew line</td></tr><tr><td align="left">回车符</td><td align="left">\r</td><td align="left"><strong>r</strong>etutn</td></tr><tr><td align="left">空格符</td><td align="left">\s</td><td align="left"><strong>s</strong>pace</td></tr><tr><td align="left">水平制表符</td><td align="left">\t</td><td align="left"><strong>t</strong>ab</td></tr><tr><td align="left">垂直制表符</td><td align="left">\v</td><td align="left"><strong>v</strong>ertical</td></tr><tr><td align="left">换页符</td><td align="left">\f</td><td align="left"><strong>f</strong>rom feed</td></tr></tbody></table><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th align="left">元字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义字符</td></tr><tr><td align="left">.</td><td align="left">代表除了换行符的字符</td></tr><tr><td align="left">(xyz)</td><td align="left">定义字符组。匹配xyz整个子串</td></tr><tr><td align="left">[ ]</td><td align="left">定义字符种类。匹配种类任意字符</td></tr><tr><td align="left">[^]</td><td align="left">定义否定除外的字符种类</td></tr><tr><td align="left">？</td><td align="left">0或1个前面的字符</td></tr><tr><td align="left">*</td><td align="left">&gt;=0个前面的字符</td></tr><tr><td align="left">+</td><td align="left">&gt;=1个前面的字符</td></tr><tr><td align="left">{min,max}</td><td align="left">闭合区间匹配字符数量指定：{min,}{定量}{min,max}</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"><strong>|</strong></td><td align="left">逻辑或，匹配前或后的字符</td></tr><tr><td align="left">[^regex]或!</td><td align="left">逻辑非，否定</td></tr></tbody></table><h2 id="定位相关字符"><a href="#定位相关字符" class="headerlink" title="定位相关字符"></a>定位相关字符</h2><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\b</td><td align="left">单词边界</td></tr><tr><td align="left">\B</td><td align="left">非单词边界</td></tr><tr><td align="left">^</td><td align="left">字符串首开始匹配</td></tr><tr><td align="left">$</td><td align="left">字符串末开始匹配</td></tr><tr><td align="left">m</td><td align="left">标志<strong>m</strong>utiline，多行模式</td></tr><tr><td align="left">i</td><td align="left">标志<strong>i</strong>gnore case，忽略大小写</td></tr><tr><td align="left">g</td><td align="left">标志<strong>g</strong>lobal search，全局搜索</td></tr></tbody></table><h2 id="常用的集成Regx"><a href="#常用的集成Regx" class="headerlink" title="常用的集成Regx"></a>常用的集成Regx</h2><table><thead><tr><th align="left">匹配区间</th><th align="left">Regx</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">除了换行符的字符</td><td align="left"><strong>.</strong></td><td align="left">一生二，二生三，三生万物</td></tr><tr><td align="left">数字，[0-9]</td><td align="left">\d</td><td align="left"><strong>d</strong>igit</td></tr><tr><td align="left">非数字，[^/d]</td><td align="left">\D</td><td align="left">not digit</td></tr><tr><td align="left">数字+字母+下划线，[a-zA-Z0-9_]</td><td align="left">\w</td><td align="left"><strong>w</strong>ord</td></tr><tr><td align="left">[^/w]</td><td align="left">\W</td><td align="left">not word</td></tr><tr><td align="left">所有空白字符【空格、制表、换页、换行、DOS终止符】[\t\n\f\t\p{Z}]</td><td align="left">\s</td><td align="left"><strong>s</strong>pace</td></tr><tr><td align="left">[^\s]</td><td align="left">\S</td><td align="left">not space</td></tr></tbody></table><h2 id="回溯查找"><a href="#回溯查找" class="headerlink" title="回溯查找"></a>回溯查找</h2><table><thead><tr><th align="left">作用</th><th align="left">Regx</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">引用</td><td align="left">\0,\1</td><td align="left">转义数字</td></tr><tr><td align="left">替换</td><td align="left">$0,$&amp;,$1</td><td align="left">结果整体：function中为$0,str中为$&amp;</td></tr><tr><td align="left">非捕获组</td><td align="left">(?:)</td><td align="left">不被单独捕获为结果</td></tr><tr><td align="left">前向查找</td><td align="left">Regx(?=content)</td><td align="left">?目标内容，=对环境内容持肯定态度</td></tr><tr><td align="left">后向查找</td><td align="left">(?&lt;=content)Regx</td><td align="left">?目标内容，&lt;目标小于content【目标在后方，向后找】，=对环境内容肯定态度</td></tr><tr><td align="left">负查找</td><td align="left">对应方向查找“=”换为“!”</td><td align="left">!对环境内容持否定态度</td></tr></tbody></table><blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><!-- [articleName](url) --></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> Regx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue|VueX</title>
      <link href="/2021/12/18/Vue-VueX/"/>
      <url>/2021/12/18/Vue-VueX/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="状态数据共享"><a href="#状态数据共享" class="headerlink" title="状态数据共享"></a>状态数据共享</h2><p>我们在基础篇组件通信中特别提到了自上而下的<strong>单向数据流</strong>，在开发应用过程中，我们经常会遇到需要在<strong>多个组件共享的数据</strong>，该如何处理它们呢？<br>试试回想组件通信的内容，如何解决共享的问题：</p><ul><li>多个视图依赖于同一状态【如何实现状态更改后的视图同步更新？】</li><li>不同视图的行为需要变更同一状态【如何才能得出期望的结果？】</li></ul><p>想想都令我头大，<code>VueX</code>就是通过把组件共享状态抽取出来，以<strong>全局单例</strong>模式实现<strong>状态数据的响应式统一管理</strong>,</p><h2 id="VueX的主要构成"><a href="#VueX的主要构成" class="headerlink" title="VueX的主要构成"></a>VueX的主要构成</h2><p><img src="/static/imgForPosts/Vue/VueX.jpeg"></p><ul><li><code>State</code>：唯一的公共数据源</li><li><code>Mutation</code>：唯一的操作公共数据途径【利于集中管控与跟踪】，必须是<strong>同步任务</strong></li><li><code>Action</code>：处理异步任务，可以在此提交Mutation操作数据</li></ul><h1 id="安装与开始"><a href="#安装与开始" class="headerlink" title="安装与开始"></a>安装与开始</h1><p><a href="https://vuex.vuejs.org/zh/">VueX文档</a></p><ul><li><p>安装<br><code>npm install vuex --save</code></p></li><li><p>导入与使用插件<br><code>import Vuex from 'vuex'</code><br><code>Vue.use(Vuex)</code></p></li><li><p>Store.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="comment">//  data</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>:&#123;</span><br><span class="line">    <span class="comment">//  methods</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="comment">//  methods</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// export</span></span><br></pre></td></tr></table></figure></li><li><p>main.js 挂载实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"> <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(app),</span><br><span class="line"> router,</span><br><span class="line"> store,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="计数应用示例"><a href="#计数应用示例" class="headerlink" title="计数应用示例"></a>计数应用示例</h1><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><ul><li>唯一的公共数据源</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="attr">state</span>:&#123; <span class="attr">count</span>: <span class="number">0</span>, &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>组件访问<code>state</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.count</span><br></pre></td></tr></table></figure><div class="note flat"><p>一般我们在组件中使用时，会将数据声明为组件的<strong>computed</strong>，方便实现双向的数据绑定</p></div><ul><li><code>mapState</code>辅助函数：批量生成<strong>computed</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="comment">// other computed</span></span><br><span class="line">    <span class="function"><span class="title">value</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapState([<span class="string">&#x27;count&#x27;</span>,])</span><br><span class="line">    <span class="comment">// ...ES6拓展运算符</span></span><br><span class="line">    <span class="comment">//相当于：</span></span><br><span class="line">    <span class="comment">// count()&#123;return this.$store.state.count&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><ul><li>提交<code>Mutation</code>：变更<code>State</code>的数据的<strong>唯一</strong>途径</li><li>这种统一管理，使得我们可以通过devTools，轻易地追溯数据的历史</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="attr">mutations</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">state,params</span>)</span>&#123;</span><br><span class="line">        state.count+=params.num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 额外参数可以是基本类型、对象</span></span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;add&#x27;</span>,&#123;</span><br><span class="line">            <span class="attr">num</span>:<span class="number">1</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapState()辅助函数</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">// 等价写法</span></span><br><span class="line">    ...mapStates(&#123;<span class="string">&#x27;add&#x27;</span>,&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用this.add()时，我们可以传入参数</span></span><br><span class="line"><span class="built_in">this</span>.add(&#123;<span class="attr">num</span>:<span class="number">1</span>,&#125;)</span><br></pre></td></tr></table></figure><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><ul><li>处理异步任务</li><li>处理过程中，可通过提交<code>Mutation</code>操作状态数据</li><li><code>Action</code>中定义的方法，默认异步，且返回<code>promise</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="comment">// context是一个与store实例具有相同方法、属性的对象</span></span><br><span class="line">    <span class="comment">// 在Modules里面有所提及</span></span><br><span class="line">    <span class="function"><span class="title">initCount</span>(<span class="params">context,url</span>)</span>&#123;</span><br><span class="line">        axios.get(url).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">&#x27;count&#x27;</span>,res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="comment">// dispatch是派发action的函数</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">initCount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.dipatch(<span class="string">&#x27;getInitialCount&#x27;</span>,url)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapActions辅助函数</span></span><br><span class="line"><span class="comment">// 与前面的辅助函数用法一致</span></span><br><span class="line">methods：&#123;</span><br><span class="line">    ...mapActions([<span class="string">&#x27;initCount&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="VueX的其他构成-TodoList为例"><a href="#VueX的其他构成-TodoList为例" class="headerlink" title="VueX的其他构成[TodoList为例]"></a>VueX的其他构成[TodoList为例]</h1><h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><ul><li>经常的，对于不同的视图，我们需要对共享数据进行一些<strong>预先处理</strong>【如过滤】，甚至<strong>派生</strong>出新的状态数据【如技术】</li><li>我们当然可以在对应视图组件，通过<code>Computed</code>处理。当如果多个视图都需要相同的处理，则可以通过<code>Getters</code>共享</li><li><code>Getters</code>类似于<code>Computed</code>，只有当它的依赖改变才会被重新计算</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="attr">getters</span>:&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="attr">doneTodos</span>:<span class="function"><span class="params">state</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span>todo.done)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以调用其他getter</span></span><br><span class="line">    <span class="attr">doneTodosCount</span>:<span class="function">(<span class="params">state,getters</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">doneTodos</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.doneTodos</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">doneTodosCount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.doneTodosCount</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapGetters()</span></span><br><span class="line">    ...mapGetters([<span class="string">&#x27;doneTodos&#x27;</span>,<span class="string">&#x27;doneTodosCount&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Modules-模块"><a href="#Modules-模块" class="headerlink" title="Modules,模块"></a>Modules,模块</h2><p>推荐研习官方文档，学习如何编写模块化的VueX<br><a href="https://vuex.vuejs.org/zh/guide/modules.html">Modules</a></p><blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><!-- [articleName](url) --></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> VueX </tag>
            
            <tag> Vue </tag>
            
            <tag> 状态管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue|基础</title>
      <link href="/2021/12/04/Vue-%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/12/04/Vue-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="UI设计模式：MVC-vs-MVVM"><a href="#UI设计模式：MVC-vs-MVVM" class="headerlink" title="UI设计模式：MVC vs MVVM"></a>UI设计模式：MVC vs MVVM</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><img src="/static/imgForPosts/Vue/MVC.jpeg"></p><ul><li>M：Model，数据模型对象【数据库的映射】</li><li>V：View，视图【页面】</li><li><code>C：</code>Controller，控制器【处理业务逻辑】</li></ul><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="/static/imgForPosts/Vue/MVVM.jpeg"></p><ul><li>M：Model</li><li>V：View</li><li><code>VM：</code>ViewModel，视图模型</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>明显的区别在于：如何把Model展现到View上，以及如何把View的输入转换成Model<br>MVC:</p><ul><li><p>针对View/Model上的变化事件，编写相互转换的Controller</p></li><li><p>除了业务逻辑，还经常要手动操作DOM,进行刷新</p></li><li><p>MVVM：为View的控件编写数据对象ViewModel，与Model关联绑定</p></li><li><p>监听DOM和Model变化进行刷新的代码封装在框架中</p></li><li><p>关心业务逻辑如何操作数据</p></li></ul><h1 id="Vue使用想法"><a href="#Vue使用想法" class="headerlink" title="Vue使用想法"></a>Vue使用想法</h1><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>编写小型、独立和通常可复用的组件构建应用</p><h2 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h2><p>对于共有的数据提取到更高的组件层级进行共享</p><h1 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h1><h2 id="Vue模板语法"><a href="#Vue模板语法" class="headerlink" title="Vue模板语法"></a>Vue模板语法</h2><ul><li>Mustache语法：<ul><li><code>&#123;&#123;&#125;&#125;</code>，会将数据解析为普通文本</li><li>支持JavaScript表达式【不是语句】，如：计算式、三目运算</li></ul></li><li>实现双向绑定：View绑定的变量写在data中即可</li><li>文本插值：<ul><li>普通文本插值：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>指令【Vue特有的属性】<code>v-once</code>,相当于const，只执行一次插值，内容不会更新</li></ul></li><li>原生HTML：在data中写入HTML语句，用<code>v-html</code>指令进行渲染：<code>v-html='param'</code></li><li>绑定属性，Arrtribute：<ul><li>指令：<code>v-bind</code></li><li>缩写：<code>:</code></li><li>例子：<code>:disabled='msg'</code>data中msg：true</li></ul></li><li>绑定事件：<ul><li>指令：<code>v-on</code></li><li>缩写：<code>@</code></li><li>例子：<code>@click='handleChange()'</code>methods中写入处理函数</li></ul></li></ul><h2 id="Vue条件语句"><a href="#Vue条件语句" class="headerlink" title="Vue条件语句"></a>Vue条件语句</h2><ul><li>v-if<ul><li>例子： v-if=’JS表达式’</li><li>v-else-if,v-else类似</li><li>复用元素时，绑定Key属性，避免重新渲染(v-for也是)</li></ul></li><li>v-show<ul><li>同上</li><li>区别：同为false时<ul><li>v-if：DOM不会渲染。</li><li>v-show将标签属性disabled设置为true</li></ul></li></ul></li><li>v-for<ul><li>例子：v-for=”item in items”，在data中定义items</li></ul></li></ul><h2 id="Vue计算属性-computed"><a href="#Vue计算属性-computed" class="headerlink" title="Vue计算属性 computed"></a>Vue计算属性 computed</h2><ul><li>解决问题：模板内嵌入过多、复杂的表达式，难以进行维护、降低可读性</li><li>使用场景：响应数据的变化，处理数据复杂逻辑计算</li><li>与函数方法method的区别：<ul><li>method触发即会执行</li><li>computed执行取决于<strong>依赖的数据是否改变</strong>，否则只会读取<strong>缓存值</strong></li><li>computed具有getter、setter函数</li></ul></li></ul><h2 id="Vue侦听-监听属性-watch"><a href="#Vue侦听-监听属性-watch" class="headerlink" title="Vue侦听/监听属性 watch"></a>Vue侦听/监听属性 watch</h2><ul><li>使用场景：数据变化时，执行异步或开销大的操作</li><li>使用：<ul><li>data中声明监听变量</li><li>v-model绑定监听变量</li><li>watch中根据用键值对绑定监听变量&amp;处理函数</li><li>注意：watch可以监听到数据变化，但是对于非基本类型不能读取到变化之前的值【因为newVal和OldVal引用是相同的】</li><li>解决：<ol><li>监听基本类型</li><li>结合computed：computed响应目标变量，进行深拷贝–&gt;watch监听computed</li></ol></li></ul></li></ul><h2 id="Vue样式绑定"><a href="#Vue样式绑定" class="headerlink" title="Vue样式绑定"></a>Vue样式绑定</h2><ul><li>v-bind绑定class<ul><li>数组语法&amp;对象语法:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>data：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    <span class="attr">isActive</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">errClass</span>:<span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>渲染结果：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>v-bind绑定style内联样式<ul><li>对象语法：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>数组语法：[styleObjects]<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>自动添加前缀：style使用需要添加引擎前缀的CSS property如transfrom，Vue会自动处理</li><li>多重值：只渲染最后一个浏览器支持的值<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Vue事件处理"><a href="#Vue事件处理" class="headerlink" title="Vue事件处理"></a>Vue事件处理</h2><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><ul><li>绑定方法<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>调用方法、传参、<strong>原始DOM事件</strong><code>$event</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>解决问题：方便地对点击、键盘等DOM事件做如<code>event.preventDefault()</code>类似的预处理</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//可串联使用</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-on的修饰符"><a href="#v-on的修饰符" class="headerlink" title="v-on的修饰符"></a>v-on的修饰符</h4><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>.stop</code></td><td align="left">阻止事件继续传播</td></tr><tr><td align="left"><code>.prevent</code></td><td align="left">阻止重载页面</td></tr><tr><td align="left"><code>.capture</code></td><td align="left">捕获模式</td></tr><tr><td align="left"><code>.self</code></td><td align="left">只有event.target为当前元素才触发事件</td></tr><tr><td align="left"><code>.once</code></td><td align="left">只触发一次【支持自定义事件】</td></tr><tr><td align="left"><code>.passive</code></td><td align="left">默认事件立即触发，不等待绑定事件执行完成</td></tr></tbody></table><div class="note warn flat"><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p></div><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p>取代按键码KeyCode用于监听键盘事件</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code>【删除&amp;退格】</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li></ul><h4 id="exact修饰符"><a href="#exact修饰符" class="headerlink" title=".exact修饰符"></a>.exact修饰符</h4><p>.exact 修饰符允许控制由<strong>精确的</strong>系统修饰符组合触发的事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>还有鼠标按键、系统修饰符就不赘述了，需要用到组合键、对应事件处理时，可以进行查阅</p></div><h2 id="Vue表单输入绑定"><a href="#Vue表单输入绑定" class="headerlink" title="Vue表单输入绑定"></a>Vue表单输入绑定</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li><code> input </code>、<code>textarea</code>、<code>select</code>表单都可以用v-model实现双向绑定</li><li>表单的<strong>初始值</strong>应该在<strong>data</strong>中声明</li><li><code>v-bind</code>绑定动态选项值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">&quot;option in options&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;option.value&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  <span class="attr">selected</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">  <span class="attr">options</span>: [</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&#x27;One&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;A&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&#x27;Two&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;B&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&#x27;Three&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;C&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li><code>.lazy</code>:在表单<code>change</code>事件后同步，而不是<code>input</code>事件</li><li><code>.number</code>：将输入值转为Number。无法解析，返回原始值</li><li><code>.trim</code>：过滤输入首尾空白符</li></ul><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>数据流是从父级向下流动的</p><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><ul><li>子组件用<code>props</code>接收父组件变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件中的子组件标签:</span></span><br><span class="line"><span class="comment">// bind后面第一个list是子组件接收用的key</span></span><br><span class="line"><span class="comment">//  第二个list是在父组件定义的变量</span></span><br><span class="line">&lt;child :list=<span class="string">&#x27;list&#x27;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;list&quot;</span> :addItem=<span class="string">&quot;addItem&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line"><span class="comment">//子组件接收</span></span><br><span class="line">props:&#123;</span><br><span class="line">    <span class="attr">menus</span>:<span class="built_in">Object</span>,</span><br><span class="line">    <span class="attr">addMenu</span>:<span class="built_in">Function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><ul><li>子组件用<code>$emit</code>触发父组件自定义事件</li><li>父组件<code>@</code>绑定的事件被触发，在事件中接收子组件参数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="comment">//@第二个addItem为父组件定义method</span></span><br><span class="line">&lt;child <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;list&#x27;</span> @addItem=<span class="string">&quot;addItem&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;addItem&#x27;</span>,item)</span><br></pre></td></tr></table></figure></li></ul><h3 id="父子间-refs-获取组件（元素）【】"><a href="#父子间-refs-获取组件（元素）【】" class="headerlink" title="父子间 $refs 获取组件（元素）【】"></a>父子间 <code>$refs</code> 获取组件（元素）【】</h3><ul><li>说明：<code>vm.$refs</code>Vue实例的一个对象属性，持有已注册过<code>ref</code><strong>标记</strong>的所有子组件（HTML元素）</li><li>使用：添加<code>ref</code>属性进行<strong>标记</strong>，通过<code>vm.$refs.属性</code>获取<ul><li>【HTML元素】获取DOM元素</li><li>【子组件】获取组件的<code>data</code>和<code>methods</code></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;bye&quot;</span>&gt;</span>Goodbye！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">ref</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;saySomething&quot;</span>&gt;</span>获取子组件中的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">saySomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//调用hello子组件data</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.hello.msg)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//调用hello子组件方法</span></span><br><span class="line">      <span class="built_in">this</span>.$refs.hello.showMsg();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用Html标签的数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.bye)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非父子通信"><a href="#非父子通信" class="headerlink" title="非父子通信"></a>非父子通信</h3><h4 id="利用父子通信，逐层传递"><a href="#利用父子通信，逐层传递" class="headerlink" title="利用父子通信，逐层传递"></a>利用父子通信，逐层传递</h4><h4 id="总线Bus-emit-on"><a href="#总线Bus-emit-on" class="headerlink" title="总线Bus $emit/$on"></a>总线Bus <code>$emit</code>/<code>$on</code></h4><ul><li>利用一个空的Vue实例，作为第三方总线中心<strong>转发</strong></li><li>利用这个中心触发/监听事件，在事件中传递数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Event=<span class="keyword">new</span> Vue();</span><br><span class="line">Event.$emit(事件名,数据);</span><br><span class="line">Event.$on(事件名,<span class="function"><span class="params">data</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Pubsub，发布订阅。作为第三方"><a href="#Pubsub，发布订阅。作为第三方" class="headerlink" title="Pubsub，发布订阅。作为第三方"></a>Pubsub，发布订阅。作为第三方</h4><ul><li><code>npm install pubsub-js</code></li><li>import后分别调用<code>subscribe</code><code>publish</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//npm安装pubsub</span></span><br><span class="line"><span class="comment">//订阅</span></span><br><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line">PubSub.subscribe(<span class="string">&#x27;someList&#x27;</span>,<span class="function">(<span class="params">msg,data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.addList(data);</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">//发布</span></span><br><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line">PubSub.publish(<span class="string">&#x27;someList&#x27;</span>,list);</span><br></pre></td></tr></table></figure><h4 id="VueX，状态管理"><a href="#VueX，状态管理" class="headerlink" title="VueX，状态管理"></a>VueX，状态管理</h4><h4 id="localStorage，本地存储"><a href="#localStorage，本地存储" class="headerlink" title="localStorage，本地存储"></a>localStorage，本地存储</h4><h2 id="v-slot插槽【V2-6统一slot-amp-slot-scope】"><a href="#v-slot插槽【V2-6统一slot-amp-slot-scope】" class="headerlink" title="v-slot插槽【V2.6统一slot&amp;slot-scope】"></a><code>v-slot</code>插槽【V2.6统一<code>slot</code>&amp;<code>slot-scope</code>】</h2><ul><li><a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md">v-slot设计描述</a></li><li>解决问题：相当于占位符，用于模板内容分发</li></ul><h3 id="具名插槽【在指定位置嵌入模板内容】"><a href="#具名插槽【在指定位置嵌入模板内容】" class="headerlink" title="具名插槽【在指定位置嵌入模板内容】"></a>具名插槽【在指定位置嵌入模板内容】</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//定义子组件插槽模板内容</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">    我是头啦~</span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">    我是尾巴啦~</span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//调用插槽</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    //模板将会被替换为插槽内容</span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//当嵌入的内容**有且仅有一个**时，我们可以简写为默认独占插槽</span><br><span class="line">//这是为了避免插槽模板作用域解析错误的问题</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><ul><li>在上一种形式，我们是<strong>不能访问插槽模板自带的数据</strong>的</li><li>下面，我们对上一种形式做出一些改变</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//定义子组件插槽模板内容</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">    绑定的title是该子组件的数据</span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//调用插槽</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;slotProps.title&#125;</span><br><span class="line">        //slotProps可以随意命名</span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//我们还可以对slotProps进行解构,对其进行操作</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>=<span class="string">&quot;&#123;title&#125;&quot;</span>&gt;</span></span><br><span class="line">    //解构</span><br><span class="line">    &#123;&#123;title&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>=<span class="string">&quot;&#123;title:myTitle&#125;&quot;</span>&gt;</span></span><br><span class="line">    //重命名</span><br><span class="line">    &#123;&#123;myTitle&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>=<span class="string">&quot;&#123;title=&#x27;newTitle&#x27;&#125;&quot;</span>&gt;</span></span><br><span class="line">    //设置默认值</span><br><span class="line">    &#123;&#123;title&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>想了解更多酷炫的应用，参考官方文档推荐的库：</p><ul><li><a href="https://github.com/Akryum/vue-virtual-scroller">Vue-Virtual-Scroller</a></li><li><a href="https://github.com/posva/vue-promised">Vue Promised</a></li><li><a href="https://github.com/LinusBorg/portal-vue">Portal Vue </a></li></ul><h2 id="Ajax通信"><a href="#Ajax通信" class="headerlink" title="Ajax通信"></a>Ajax通信</h2><p>Vue2推荐axios来完成，简单写下get请求demo<br><a href="https://github.com/axios/axios">axios</a><br><a href="http://www.axios-js.com/">axios文档</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url=<span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line">axios.get(url).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;success:&quot;</span>+&#123;&#123;res.data&#125;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        alert(err)</span><br><span class="line">    &#125;)</span><br><span class="line">    .finally(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="VueRouter路由"><a href="#VueRouter路由" class="headerlink" title="VueRouter路由"></a>VueRouter路由</h2><p><a href="https://router.vuejs.org/zh/">VueRouter文档</a></p><ul><li>使用方法：<ul><li>pages文件夹：放置编写的页面</li><li>router文件夹：放置路由文件</li><li>router.js:导入vue、vue-router【命名为VueRouter】<ul><li>vue.use(VueRouter)【vue使用该插件】</li><li>export default new VueRouter ({config of routes}),导出路由实例</li></ul></li><li>main.js:项目入口，导入路由router.js实例，并挂载到Vue实例上</li><li>渲染：<ul><li>路由页面显示：<router-view></router-view></li><li>跳转链接：<router-link to="Routerpath"></router-link></li><li>路由页面缓存:<keep-alive><router-view/></keep-alive>可避免重复加载</li></ul></li></ul></li></ul><h3 id="Router-js"><a href="#Router-js" class="headerlink" title="Router.js"></a>Router.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">&#x27;../pages/index.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Student <span class="keyword">from</span> <span class="string">&#x27;../pages/student.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> StudentMenu1 <span class="keyword">from</span> <span class="string">&#x27;../pages/studentMenu1.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> StudentMenu2 <span class="keyword">from</span> <span class="string">&#x27;../pages/studentMenu2.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Teacher <span class="keyword">from</span> <span class="string">&#x27;../pages/teacher.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TeacherMenu <span class="keyword">from</span> <span class="string">&#x27;../pages/teacherMenu.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue使用插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出路由实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/index&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: index</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/student&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: Student,</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//子路由</span></span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;/student/studentMenu1&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>: studentMenu1</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;/student/studentMenu2&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>: studentMenu2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                    <span class="attr">redirect</span>: <span class="string">&quot;/student/studentMenu1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="attr">redirect</span>: <span class="string">&#x27;/index&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/teacher&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: Teacher,</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;/teacher/teacherMenu&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>: TeacherMenu</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//重定向</span></span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                    <span class="attr">redirect</span>: <span class="string">&#x27;/teacher/teacherMenu&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/router.js&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(axios)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  <span class="comment">//router:router,</span></span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="展示页面示例"><a href="#展示页面示例" class="headerlink" title="展示页面示例"></a>展示页面示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/index&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/student&quot;</span>&gt;</span>学生信息<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/teacher&quot;</span>&gt;</span>教师信息<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    //keep-alive缓存，可以在切换时，避免重新加载页面</span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由组件传参，声明式路由导航"><a href="#路由组件传参，声明式路由导航" class="headerlink" title="路由组件传参，声明式路由导航"></a>路由组件传参，声明式路由导航</h3><div class="note flat"><p>注意区分：<br><code>router</code>是全局对象，是我们在<code>router.js</code>创建和导出的的<code>vueRouter</code>实例</p><p><code>route</code>是局部对象，是当前路由页面的路由</p></div><p>介绍<code>$route.params</code>&amp;<code>$route.query</code>两种途径<br>流程梳理：【用户行为–&gt;视图变更】</p><ul><li>用户点击<code>router-link</code>,<code>url</code>更改</li><li>url匹配到router的对应route，该route属性parmas/query接收并设置参数</li><li>在展示页面，我们通过<code>route.params</code>或<code>route.query</code>获取参数，根据参数展现不同内容</li></ul><h4 id="route-params"><a href="#route-params" class="headerlink" title="$route.params"></a><code>$route.params</code></h4><h5 id="router-js，路由配置片段"><a href="#router-js，路由配置片段" class="headerlink" title="router.js，路由配置片段"></a>router.js，路由配置片段</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/teacher&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Teacher,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 我们希望根据id，点击对应router-link把不同教师的信息渲染到Menu这个组件中</span></span><br><span class="line">            <span class="comment">// 这里我们为route路径设置一个动态路径参数id</span></span><br><span class="line">            <span class="comment">// 我们也可以设置多段动态参数，但这里不需要</span></span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/teacher/teacherMenu/:id&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: TeacherMenu,</span><br><span class="line">            <span class="attr">props</span>:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//重定向</span></span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="attr">redirect</span>: <span class="string">&#x27;/teacher/teacherMenu&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="展示页面"><a href="#展示页面" class="headerlink" title="展示页面"></a>展示页面</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(teacher,index) in teachers&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;teacher.id&quot;</span>&gt;</span></span><br><span class="line">                //生成多个link</span><br><span class="line">              <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;`/teacher/teacherMenu/$&#123;teacher.id&#125;`&quot;</span>&gt;</span>&#123;&#123;teacher.name&#125;&#125;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    //我们可以从当前匹配route中取到id</span><br><span class="line">    //注意：组件会被复用---&gt;生命周期钩子不再调用</span><br><span class="line">    //有需求可以通过watch或beforeRouteUpdate处理</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;$route.params.id&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="query方式"><a href="#query方式" class="headerlink" title="query方式"></a><code>query</code>方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/teacher&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Teacher,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 去掉:id即可</span></span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/teacher/teacherMenu/&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: TeacherMenu,</span><br><span class="line">            <span class="attr">props</span>:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//link</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;`/teacher/teacherMenu?id=$&#123;teacher.id&#125;`&quot;</span>&gt;</span>&#123;&#123;teacher.name&#125;&#125;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//展示</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">//从query属性查询当前路由对象的id</span><br><span class="line">      &#123;&#123;$route.query.id&#125;&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><p>借助我们的全局实例<code>router</code>,取代<code>router-link</code>来实现路由跳转</p><ul><li><p>对象方法属性：</p><ul><li>push(入history栈，可退回)</li><li>replace(替换，不可退回)</li><li>back</li></ul></li><li><p>用法举例：</p><ul><li>绑定click事件和method</li><li>method中使用router的方法</li><li>如：<code>this.$router.push(path)</code></li></ul></li></ul><blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><!-- [articleName](url) --></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 框架 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React|Redux</title>
      <link href="/2021/11/20/React-Redux/"/>
      <url>/2021/11/20/React-Redux/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="状态【State】共享的困难"><a href="#状态【State】共享的困难" class="headerlink" title="状态【State】共享的困难"></a>状态【State】共享的困难</h1><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>父组件状态单向传输到子组件<br><img src="/static/imgForPosts/Redux/stateShare1.gif"></p><h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>当组件层级较浅时，我们可以把非父子组件需要共享的State，提升到共同的祖先组件进行管理<br><img src="/static/imgForPosts/Redux/stateShare2.gif"></p><h2 id="分层更复杂的情况"><a href="#分层更复杂的情况" class="headerlink" title="分层更复杂的情况"></a>分层更复杂的情况</h2><p>当组件层级愈发深时，跨组件State共享也越来越复杂,使用<strong>状态提升</strong>的开销也更多<br><img src="/static/imgForPosts/Redux/stateShare3.gif"></p><p>举个例子，实现组件B操作组件C，如图：</p><ul><li>把<code>handleClick</code>方法，一层层传递给组件B</li><li>组件B调用<code>handleClick</code>方法，一层层调用，直到修改组件A的<code>state</code></li><li>组件A到组件C之间的<strong>所有组件都会触发重新渲染</strong></li></ul><p><img src="/static/imgForPosts/Redux/stateShare4.jpeg"></p><h2 id="状态管理库"><a href="#状态管理库" class="headerlink" title="状态管理库"></a>状态管理库</h2><p>如Redux、Vuex等状态管理模块，就是通过建立一个<strong>唯一的且状态统一的第三方中心</strong>，实现跨组件的状态共享<br><img src="/static/imgForPosts/Redux/stateShare5.gif"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><p><img src="/static/imgForPosts/Redux/reduxConception.jpeg"></p><ul><li>View：视图层 【指挥官】</li><li>Action：根据不同的<strong>组件事件</strong>选择触发<code>Reducer</code>对应的<strong>更新处理方法</strong> 【信号兵】</li><li>Reducer：描述<strong>如何更新</strong>State 【军队】</li><li>Store：<strong>唯一</strong>的state管理中心，State保存在这里 【城池】</li></ul><p>形象描述下流程：</p><ol><li>View指挥官：发出指令，如攻击</li><li>Action信号兵：根据攻击指令—选择红色信号弹发射</li><li>Reuducer军队：根据红色信号弹，做出攻击城池行为【修改城池状态】</li></ol><h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><p><strong>单一数据源</strong>：</p><ul><li>整个React应用的<code>State</code>,储存在一个<code>Object Tree</code>中，这个<code>Object Tree</code>只存在于<strong>唯一一个</strong><code>store</code>中</li></ul><p><strong>State是只读的</strong></p><ul><li>唯一改变<code>State</code>的方法时<code>dispatch</code>触发<code>action</code></li></ul><p><strong>使用纯函数来执行修改</strong></p><ul><li>reducer：接收state、action，返回newState</li><li>纯函数：<ul><li>同一输入，输出不变</li><li>不依赖外部变量</li><li>不修改外部变量【不产生副作用】</li></ul></li></ul><h1 id="实践【TodoList-展示列表部分】"><a href="#实践【TodoList-展示列表部分】" class="headerlink" title="实践【TodoList-展示列表部分】"></a>实践【TodoList-展示列表部分】</h1><ul><li>(Redux官方示例)[<a href="https://www.redux.org.cn/docs/introduction/Examples.html]">https://www.redux.org.cn/docs/introduction/Examples.html]</a></li><li>(Redux官方Todo示例)[<a href="https://github.com/reduxjs/redux/tree/master/examples/todos/src]">https://github.com/reduxjs/redux/tree/master/examples/todos/src]</a> </li></ul><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app react-todo</span><br><span class="line">cd react-todo</span><br><span class="line">cd src</span><br><span class="line">del *</span><br><span class="line"></span><br><span class="line">npm i redux</span><br><span class="line">npm i react-redux</span><br></pre></td></tr></table></figure><h2 id="Redux实践结构"><a href="#Redux实践结构" class="headerlink" title="Redux实践结构"></a>Redux实践结构</h2><p><img src="/static/imgForPosts/Redux/reduxPractice.jpeg"><br>我们在核心流程的基础上，针对view层分离出：</p><ul><li><p>容器组件：</p><ul><li>对State、触发方法进行<strong>逻辑描述</strong>，提供给纯展示组件调用，<strong>包裹纯展示组件</strong></li><li>即：【将原view层的state响应逻辑抽离出来】</li></ul></li><li><p>展示组件：</p><ul><li>接收<strong>容器组件</strong>的数据，渲染展示</li></ul></li></ul><h2 id="实现功能及主要文件目录"><a href="#实现功能及主要文件目录" class="headerlink" title="实现功能及主要文件目录"></a>实现功能及主要文件目录</h2><p>实现功能：</p><ol><li>展示Todolist</li><li>点击Todo项，更改状态</li><li>点击过滤选项，过滤Todolist<br>主要文件目录：</li></ol><ul><li>src<ul><li>store:创建store实例<ul><li>index.js</li></ul></li><li>actions：<ul><li>index.js</li></ul></li><li>reducers：分割不同的state及对应更新处理<ul><li>index.js</li><li>todo.js</li><li>filter.js</li></ul></li><li>containers：存放容器组件<ul><li>VisibleTodoList.js</li><li>FilterLink.js</li></ul></li><li>components：展示和主组件<ul><li>App.js</li><li>TodoList.js</li><li>Todo.js</li><li>Link.js</li></ul></li></ul></li><li>index.js:入口文件</li></ul><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="actions文件夹"><a href="#actions文件夹" class="headerlink" title="actions文件夹"></a>actions文件夹</h3><ul><li>index.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Todo id</span></span><br><span class="line"><span class="keyword">let</span> nextTodoId = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的过滤类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> VisibilityFilters = &#123;</span><br><span class="line">    <span class="attr">SHOW_ALL</span>: <span class="string">&quot;SHOW_ALL&quot;</span>,</span><br><span class="line">    <span class="attr">SHOW_COMPLETED</span>: <span class="string">&quot;SHOW_COMPLETED&quot;</span>,</span><br><span class="line">    <span class="attr">SHOW_ACTIVE</span>: <span class="string">&quot;SHOW_ACTIVE&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击Todo的action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTodo=<span class="function"><span class="params">id</span>=&gt;</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;TOGGLE_TODO&#x27;</span>,</span><br><span class="line">    id</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击过滤选项的action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibilityFilter=<span class="function"><span class="params">filter</span>=&gt;</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">    filter,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="reducers文件夹"><a href="#reducers文件夹" class="headerlink" title="reducers文件夹"></a>reducers文件夹</h3><ul><li>todo.js</li></ul><p>State中的todos和对应更新方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始数据</span></span><br><span class="line"><span class="keyword">const</span> initialTodoState=[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">text</span>:<span class="string">&#x27;tools&#x27;</span>,</span><br><span class="line">        <span class="attr">completed</span>:<span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="attr">text</span>:<span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">        <span class="attr">completed</span>:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="number">3</span>,</span><br><span class="line">        <span class="attr">text</span>:<span class="string">&#x27;article&#x27;</span>,</span><br><span class="line">        <span class="attr">completed</span>:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="number">4</span>,</span><br><span class="line">        <span class="attr">text</span>:<span class="string">&#x27;Date&#x27;</span>,</span><br><span class="line">        <span class="attr">completed</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos=<span class="function">(<span class="params">state=initialTodoState,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;TOGGLE_TODO&quot;</span>:&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>  state.map(<span class="function">(<span class="params">item</span>)=&gt;</span></span><br><span class="line">                        item.id===action.id?</span><br><span class="line">                        &#123;...item,<span class="attr">completed</span>:!item.completed&#125;:item</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todos;</span><br></pre></td></tr></table></figure><ul><li>filter.js</li></ul><p>State中的filter和对应更新方法，用于过滤</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;VisibilityFilters&#125; <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filter=<span class="function">(<span class="params">state=VisibilityFilters.SHOW_ALL,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;SET_VISIBILITY_FILTER&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> action.filter</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> filter</span><br></pre></td></tr></table></figure><ul><li>index.js</li></ul><p>组合分割的State及更新方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> todos <span class="keyword">from</span> <span class="string">&#x27;./todos&#x27;</span></span><br><span class="line"><span class="keyword">import</span> filter <span class="keyword">from</span> <span class="string">&#x27;./filter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// combineReducers-API会组合多个reducer的State</span></span><br><span class="line">    <span class="comment">// 这个State树会【自动存储】到【Redux State】</span></span><br><span class="line">    <span class="comment">// 当dispath触发action对应行为时，会自动遍历响应正确case</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">    todos,</span><br><span class="line">    filter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="store文件夹"><a href="#store文件夹" class="headerlink" title="store文件夹"></a>store文件夹</h3><ul><li>index.js</li></ul><p>创建store实例，使用中间件如redux-devtools加工</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> combineReducers <span class="keyword">from</span> <span class="string">&#x27;../reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store=</span><br><span class="line">createStore(combineReducers,<span class="built_in">window</span>._REDUX_DEVTOOLS_EXTENSION &amp;&amp;</span><br><span class="line"><span class="built_in">window</span>._REDUX_DEVTOOLS_EXTENSION)</span><br></pre></td></tr></table></figure><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><ul><li>index.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./components/App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provider包裹的组件可以访问Provider的属性</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="主组件"><a href="#主组件" class="headerlink" title="主组件"></a>主组件</h3><ul><li>App.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VisibleTodoList <span class="keyword">from</span> <span class="string">&quot;../containers/VisibleTodoList&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">&quot;./Footer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; filter &#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">VisibleTodoList</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Footer</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">filter</span>=<span class="string">&#123;filter&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provider的sttate+组件props---&gt;新的组件props</span></span><br><span class="line">    <span class="comment">// class组件：this.props访问</span></span><br><span class="line">    <span class="comment">// func组件：props访问</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function">(<span class="params">state,props</span>)=&gt;</span>(&#123;</span><br><span class="line">  <span class="attr">filter</span>:state.filter</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(App)</span><br><span class="line"><span class="comment">// connect---用于向对应组件注入state</span></span><br></pre></td></tr></table></figure><h3 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h3><p>将原view层的state更新事件响应逻辑抽离出来</p><ul><li>传递state</li><li>响应更新，dispatch</li></ul><ul><li>VisibleTodoList.js</li></ul><p>TodoList的容器组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;ract-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; toggleTodo &#125; <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;VisibilityFilters&#125; <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">&#x27;../components/TodoList&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据【filter状态】过滤出用于UI展示的list数据</span></span><br><span class="line"><span class="keyword">const</span> getVisibleTodos=<span class="function">(<span class="params">todos,filter</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(filter)&#123;</span><br><span class="line">        <span class="keyword">case</span> VisibilityFilters.SHOW_ALL:</span><br><span class="line">            <span class="keyword">return</span> todos;</span><br><span class="line">        <span class="keyword">case</span> VisibilityFilters.SHOW_COMPLETED:</span><br><span class="line">            <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">item</span>=&gt;</span>item.completed);</span><br><span class="line">        <span class="keyword">case</span> SHOW_ACTIVE:</span><br><span class="line">            <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">item</span>=&gt;</span>!item.completed)</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Unknown filter: &quot;</span>+filter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function"><span class="params">state</span>=&gt;</span>(&#123;</span><br><span class="line">    <span class="attr">todos</span>:getVisibleTodos(state.todos,state.filter)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让UI组件直接通过属性调用dispatch</span></span><br><span class="line"><span class="keyword">const</span> mapDispathToprops=<span class="function"><span class="params">dispatch</span>=&gt;</span>(&#123;</span><br><span class="line">    <span class="attr">toggleTodo</span>:<span class="function"><span class="params">id</span>=&gt;</span>dispatch(toggleTodo(id))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出包裹【注入state的UI组件】的容器组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispathToprops)(TodoList)</span><br></pre></td></tr></table></figure><ul><li>FilterLink.js</li></ul><p>Link组件的容器组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; setVisibilityFilter &#125; <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;../components/Link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps=<span class="function">(<span class="params">state,ownProps</span>)=&gt;</span>(&#123;</span><br><span class="line">    <span class="attr">active</span>:ownProps.filter===state.filter</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps=<span class="function">(<span class="params">dispatch,ownProps</span>)=&gt;</span>(&#123;</span><br><span class="line">    <span class="attr">onClcik</span>:<span class="function">()=&gt;</span>dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapDispatchToProps)(Link)</span><br></pre></td></tr></table></figure><h3 id="展示组件"><a href="#展示组件" class="headerlink" title="展示组件"></a>展示组件</h3><ul><li>TodoList.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">&#x27;./Todo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象解构&#123;&#125;访问props</span></span><br><span class="line"><span class="keyword">const</span> TodoList=<span class="function">(<span class="params">&#123;todos,toggleTodo&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;todos.map((item)=&gt;(</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Todo</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    &#123;<span class="attr">...item</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>toggleTodo(item.id)&#125;</span></span><br><span class="line"><span class="xml">                /&gt;</span></span><br><span class="line"><span class="xml">            ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行时：输入类型校验</span></span><br><span class="line">TodoList.propTypes=&#123;</span><br><span class="line">    <span class="attr">todos</span>:PropTypes.arrayOf(</span><br><span class="line">        PropTypes.shape(&#123;</span><br><span class="line">            <span class="attr">id</span>:PropTypes.number.isRequired,</span><br><span class="line">            <span class="attr">completed</span>:PropTypes.bool.isRequired,</span><br><span class="line">            <span class="attr">text</span>:PropTypes.string.isRequired</span><br><span class="line">        &#125;).isRequired</span><br><span class="line">    ).isRequired,</span><br><span class="line">    <span class="attr">toggleTodo</span>:PropTypes.func.isRequired</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会在容器组件VisibleTodoList注入状态state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoList</span><br></pre></td></tr></table></figure><ul><li>Todo.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Todo</span>(<span class="params">&#123;onCLick,completed,text&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">onClick</span>=<span class="string">&#123;onCLick&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">textDecoration:completed</span>?&#x27;<span class="attr">line-through</span>&#x27;<span class="attr">:</span>&#x27;<span class="attr">none</span>&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        &gt;</span></span></span><br><span class="line"><span class="xml">            &#123;text&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Todo.propTypes = &#123;</span><br><span class="line">    <span class="attr">onClick</span>:PropTypes.func.isRequired,</span><br><span class="line">    <span class="attr">completed</span>:PropTypes.bool.isRequired,</span><br><span class="line">    <span class="attr">text</span>:PropTypes.string.isRequired</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Todo</span><br></pre></td></tr></table></figure><ul><li>Footer.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;VisibilityFilters&#125; <span class="keyword">from</span> <span class="string">&#x27;../actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> FilterLink <span class="keyword">from</span> <span class="string">&#x27;../containers/FilterLink&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Footer=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>Show：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">FilterLink</span> <span class="attr">filter</span>=<span class="string">&#123;VisibilityFilters.SHOW_ALL&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                All</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">FilterLink</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">FilterLink</span> <span class="attr">filter</span>=<span class="string">&#123;VisibilityFilters.SHOW_COMPLETED&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                Done</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">FilterLink</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">FilterLink</span> <span class="attr">filter</span>=<span class="string">&#123;VisibilityFilters.SHOW_ACTIVE&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                Undone</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">FilterLink</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Footer</span><br></pre></td></tr></table></figure><ul><li>Link.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Children &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// props.chidren</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Link</span>(<span class="params">&#123;children,onClick,active&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">disabled</span>=<span class="string">&#123;active&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;children&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Link.propTypes = &#123;</span><br><span class="line">    <span class="attr">children</span>:PropTypes.node.isRequired,</span><br><span class="line">    <span class="attr">onClick</span>:PropTypes.func.isRequired,</span><br><span class="line">    <span class="attr">active</span>:PropTypes.bool.isRequired</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Link</span><br></pre></td></tr></table></figure><div class="note flat"><p>参考文章：</p><ol><li><a href="https://www.redux.org.cn/">Redux官方文档</a></li><li><a href="https://juejin.cn/post/6844904037620400136">使用容器&amp;UI组件进一步分离组件状态</a></li><li><a href="https://juejin.cn/post/6844903702466134029">关于前端组件化、状态管理规范化的思考</a></li></ol></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
            <tag> 状态管理 </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React|基础</title>
      <link href="/2021/10/30/React-%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/10/30/React-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前刚开始实习，一周后就要和同事一同接手新平台的开发。老大要求采用<code>React&Hooks</code>，让我赶快学习…所以后面抽空写了这篇文章<br>可惜的是，项目使用的是老大二次封装的基于model的reactHooks，没有机会写传统的React</p><p>因为我之前是用<code>Vue</code>的，所以学习中会想要理解它们的异同，一些主要差异概括我都放在<strong>前言</strong>，不感兴趣的同学可以跳过哈~</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>React是由Facebook自研的JS框架<br><a href="https://cn.vuejs.org/v2/guide/comparison.html">Vue官方诠释与其他框架的对比</a></p><h2 id="Vue与React的异同"><a href="#Vue与React的异同" class="headerlink" title="Vue与React的异同"></a>Vue与React的异同</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都使用<code>Virtual DOM</code>+<code>Diff</code>算法<ul><li>减少直接操作DOM，减少频繁<strong>整体</strong>更新DOM，实现数据驱动视图</li><li>支持函数式编程<strong>【React核心思想，Vue推荐使用模板】</strong></li><li>跨平台，渲染到不支持DOM（Web）之外的平台</li></ul></li><li>组件化思想&amp;更新流程<ul><li>(Vue)Template/(React)JSX–&gt;render函数—&gt;生成VNode—&gt;变化—&gt;new/old VNode diff算法更新—&gt;更新真实DOM</li></ul></li><li>响应式数据&amp;单向数据流</li><li>支持服务端渲染</li></ol><h3 id="差异点"><a href="#差异点" class="headerlink" title="差异点"></a>差异点</h3><ol><li>核心思想定位：<ul><li>【Vue】简单易上手，渐进式开发。<strong>官方主导</strong>上层应用解决方案开发</li><li>【React】Rethinking Best Practices，重新思考最佳实践。只关注底层，上层应用解决方案交给社区</li></ul></li><li>写法&amp;api<ul><li>【Vue】推崇<strong>Template、单文件Vue</strong>。【支持JSX,需要babel转换】</li><li>【React】推崇<strong>函数式编程</strong>，JSX、<strong>All in JavaScript</strong>、高阶组件HOC</li></ul></li><li>响应式原理<ul><li>【Vue】基于<strong>依赖收集，自动优化，数据可变</strong><ul><li>Vue递归监听data所有属性，直接更改</li><li>数据改变时，<strong>自动查找引用组件并重新渲染</strong></li></ul></li><li>【React】基于<strong>状态机，手动优化，数据不可变</strong>，需要<code>setState</code>来更新<ul><li>数据改变时，<strong>以组件为根目录，默认全部重新渲染</strong></li><li>通过<code>shouldComponentUpdate</code>或<code>PureComponent</code>来避免必要的渲染</li></ul></li></ul></li></ol><h1 id="JSX-JavaScript-XML"><a href="#JSX-JavaScript-XML" class="headerlink" title="JSX:JavaScript XML"></a>JSX:JavaScript XML</h1><p>在React中，我们将使用JSX编写React元素取代Vue的模板</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="嵌入JS表达式-amp-amp-JSX也是表达式"><a href="#嵌入JS表达式-amp-amp-JSX也是表达式" class="headerlink" title="嵌入JS表达式 &amp;&amp; JSX也是表达式"></a>嵌入JS表达式 &amp;&amp; JSX也是表达式</h3><ul><li>注释：<code>&#123;/<em>text</em>/&#125;</code></li><li>注意：<ul><li>写多行标签必须要用唯一一个父标签(如例子中的div)包裹</li><li>JSX最好用<code>( )</code>包裹。这会避免自动插入分号导致的错误</li></ul></li><li>嵌入<strong>任意有效的JS表达式</strong>，只需用<code>&#123; &#125;</code>包裹</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&#x27;reactDom&#x27;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text=<span class="string">&#x27;Hellobb&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JSX也是表达式</span></span><br><span class="line"><span class="comment">// 意味着：JSX可以：嵌入ifelse代码块、赋值给变量、当作参数传入、函数中返回</span></span><br><span class="line"><span class="keyword">let</span> jsxDom=(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;good morning!&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;&#123;text&#125;&lt;p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">    jsxDom,</span><br><span class="line">    document.getElementById(&quot;reactDom&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="JSX特定属性"><a href="#JSX特定属性" class="headerlink" title="JSX特定属性"></a>JSX特定属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 引号 ，将属性值指定为字符串字面量</span></span><br><span class="line"><span class="keyword">const</span> el= <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 大括号 ， 属性值中插入JS表达式</span></span><br><span class="line"><span class="keyword">const</span> el2=<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><h3 id="样式设置"><a href="#样式设置" class="headerlink" title="样式设置"></a>样式设置</h3><p><code>ReactDOM</code>的属性采用<strong>小驼峰命名</strong>，与<code>HTML</code>不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myStyle=&#123;<span class="attr">color</span>:<span class="string">&#x27;purple&#x27;</span>,<span class="attr">fontSize</span>:<span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSX中</span></span><br><span class="line">(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;myStyle&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;mycalss&#x27;</span>&gt;</span>注意是className<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><div class="note flat"><p>Vue：</p><ul><li>vue单文件</li><li>表达式插入使用Mustache<code>&#123;&#123;&#125;&#125;</code></li></ul><p>React：</p><ul><li>JSX/JS表示组件，分为<code>Class</code>、<code>Function</code>两种组件。</li><li>表达式插入使用<code>&#123;&#125;</code></li><li>组件名称<strong>大写开头</strong>，小写开头将被视为原生HTML标签</li></ul></div><blockquote><p>Class组件：</p><ul><li>有状态的</li><li>可接收<code>props</code></li></ul><p>Function组件：</p><ul><li>无状态的</li><li>可接收<code>props</code></li><li>React16更新的<code>Hooks</code>让它也能管理<code>State</code></li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewCom</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Compont</span></span>&#123;</span><br><span class="line">    <span class="comment">// ES6中：new实例会自动补上constructor，所以我们可以不写</span></span><br><span class="line">    <span class="comment">// 一旦写了，必须加上super(),调用父类的构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 若要在constructor中使用props，constructor&amp;super都需显式加上props</span></span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state=&#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;NewCom&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> NewCom</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无状态的Function组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GreetCom</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    props.name=props.name||<span class="string">&#x27;default Name&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello,&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> GreetCom</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用hooks管理state</span></span><br><span class="line"><span class="keyword">import</span> React &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GreetCom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName]=useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> GreetCom</span><br></pre></td></tr></table></figure><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><div class="note flat"><p>分为两部分：</p><ul><li>父组件传递的数据props</li><li>组件自身的数据data/state</li></ul><p>Vue:</p><ul><li>静态props：组件属性绑定静态字符串即可</li><li>动态props：<code>v-bind:attribute="变量"</code></li><li>data：Vue递归将data属性转为getter/setter，实现响应式</li></ul><p>React:</p><ul><li>静态props：同</li><li>动态props：属性绑定<code>&#123;变量&#125;</code></li><li>state:在<code>constructor</code>定义<code>state</code>,修改数据<strong>必须</strong> <code>setState</code></li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态props</span></span><br><span class="line"><span class="comment">// 注意Class组件用 this.props 读取 props</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewCom</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ele=<span class="xml"><span class="tag">&lt;<span class="name">NewCom</span> <span class="attr">name</span>=<span class="string">&#x27;Kervin&#x27;</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态props</span></span><br><span class="line"><span class="keyword">const</span> ele=<span class="xml"><span class="tag">&lt;<span class="name">NewCom</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class使用state</span></span><br><span class="line"><span class="comment">// Function中Hooks的使用我将在另外的文章阐述</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewCom</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;NewCom&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class类方法定义，‘this’在函数默认为‘undefined’</span></span><br><span class="line">    <span class="comment">// 我们需要进行‘this’绑定</span></span><br><span class="line">    <span class="comment">// 我们将会在别的文章详细探讨这个问题，感兴趣的可以去查找资料了解喔~</span></span><br><span class="line">    <span class="comment">// 又挖坑了O(∩_∩)O哈哈~</span></span><br><span class="line">    <span class="built_in">this</span>.changeName = <span class="built_in">this</span>.changeName.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">changeName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    <span class="comment">//setState更新部分数据，react会自动合并 </span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;A new name&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeName&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若要使用上一个state，我们可以传入一个函数</span></span><br><span class="line"><span class="comment">// 这个函数返回一个自定义对象，注意箭头后这个对象用 “()”包裹了</span></span><br><span class="line"><span class="comment">// 这是因为大括号原本是 函数主体的标志 ，避免了歧义</span></span><br><span class="line"><span class="comment">// props是更新用的参数</span></span><br><span class="line"><span class="built_in">this</span>.setState(</span><br><span class="line">    <span class="function">(<span class="params">state,props</span>)=&gt;</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>:state.name+props.name</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><div class="note flat"><p>Vue:</p><ul><li>父子组件：prop+自定义事件</li><li>兄弟组件：Bus、父子、</li><li>跨组件：provide/inject、VueX…</li></ul><p>React:</p><ul><li>父子组件：props+回调</li><li>兄弟组件：类似</li><li>Context、Redux…【Redux将在别的文章阐述】</li></ul></div><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><p>父组件使用<code>props</code>传递数据、<strong>回调函数</strong>给子组件—&gt;子组件通过回调函数返回数据—&gt;父组件回调中获取数据，调用自身函数更改数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class写法</span></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.props.fatherFun(<span class="built_in">this</span>.state.sonText)</span><br><span class="line">&#125;&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">fatherFun</span>=<span class="string">&#123;(sonText)</span>=&gt;</span>this.changeData(sonText)&#125;/&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.sonText&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">changeData=<span class="function">(<span class="params">text</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;<span class="attr">sonText</span>:text&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function</span></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;backEvent&#125;=props</span><br><span class="line">    <span class="keyword">const</span> [text,setText]=useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changeText=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        setText(<span class="string">&#x27;new Text&#x27;</span>)</span><br><span class="line">        backEvent(<span class="string">&#x27;new Text&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;changeText&#125;</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> showText=<span class="function"><span class="params">text</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(text)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">backEvent</span>=<span class="string">&#123;showText&#125;/</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨组件通信"><a href="#跨组件通信" class="headerlink" title="跨组件通信"></a>跨组件通信</h2><ul><li>Context:无需手动在<strong>每层</strong>添加<code>props</code>，实现在组件树间传递数据</li><li>用法：<ul><li>在父组件创建Context对象</li><li>通过<code>Context.Provider</code>的value属性向消费组件传值</li></ul></li><li><strong>注意</strong>：当作为<code>Provider</code>的祖先组件<strong>重新渲染</strong>时，作为<code>Comsumer</code>的组件<strong>不可避免地会重新渲染</strong>，所以不建议使用<code>Context</code></li></ul><p>父组件传值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Context对象</span></span><br><span class="line"><span class="keyword">const</span> NewContext=React.createContext(&#123;<span class="attr">msg</span>:<span class="string">&#x27;No Money&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> showText=<span class="function"><span class="params">text</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context.provider传值</span></span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line">    &lt;NewContext.Provider value=&#123;&#123;msg:&#x27;Some Money&#x27;&#125;&#125;&gt;</span><br><span class="line">        &lt;Son backEvent=&#123;showText&#125;/&gt;</span><br><span class="line">    &lt;NewContext.Provider&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>子组件获取值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class组件</span></span><br><span class="line"><span class="comment">// 通过contextType获取</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> contextType=NewContext</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.context.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Funtion组件</span></span><br><span class="line"><span class="comment">// 通过Context.Consumer订阅获取</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">NewContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;</span></span><br><span class="line"><span class="xml">                (value)=&gt;(</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                )</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">NewContext.Consumer</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ref引用"><a href="#ref引用" class="headerlink" title="ref引用"></a>ref引用</h1><div class="note flat"><p><code>ref</code>用于给元素<strong>注册引用</strong>，允许我们访问子元素</p><p>常见场景：</p><ul><li>管理焦点、媒体播放</li><li>表单校验</li><li>触发强制动画</li></ul><p>Vue:</p><ul><li>通过设置子组件<code>ref</code>属性的值，相当于赋予一个身份证</li><li>父组件通过<code>this.$refs.ID</code>来直接操作子组件</li><li>注意：<code>$refs</code>只会在<strong>组件渲染完后</strong>生效，<strong>非响应式</strong>，避免在模板、computed中访问</li></ul><p>React:</p><ul><li><code>class</code>组件通过<code>React.createRef</code>绑定<code>ref</code>属性</li><li><code>Function</code>组件通过<code>useRef</code>绑定<code>ref</code>属性</li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class组件</span></span><br><span class="line"><span class="comment">// 生成ref绑定到input元素上，加载完成自动聚焦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">mesg</span>: <span class="string">&#x27;newCom&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.inputRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.inputRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; msg &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">type</span>=<span class="string">&quot;number&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">ref</span>=<span class="string">&#123;this.inputRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useRef返回可变的ref对象</span></span><br><span class="line"><span class="comment">// .current属性初始化为传入的initialValue,这里传入的是空数组[]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [message, setMessage] = useState(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><div class="note flat"><p>Vue:</p><ul><li>v-if、v-else、v-else-if</li></ul><p>React:</p><ul><li>与&amp;&amp;</li><li>三目?:</li><li>if else、switch case</li><li>JSX里面可以嵌入任意有效JS表达式值，但注意不能使用if，if条件判断是一个语句、行为</li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp;&amp;</span></span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;showContent &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ?:</span></span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;</span></span><br><span class="line"><span class="xml">            showContent?</span></span><br><span class="line"><span class="xml">            (<span class="tag">&lt;<span class="name">div</span>&gt;</span>true<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">            :(<span class="tag">&lt;<span class="name">div</span>&gt;</span>false<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if、else就不赘述了，看看switch case</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;type&#125;=<span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> changeShow=<span class="function">(<span class="params">type</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;changeShow(type)&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><div class="note flat"><p>Vue:</p><ul><li>v-for</li></ul><p>React:</p><ul><li>map</li><li>for in、for of、Object.keys()、 Object.entries()等等…。</li><li>下面仅以map为例</li></ul><p>【注意：指定唯一的key属性，Vue/React节点更新都基于VirtualDOM&amp;&amp;diff算法】</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用Array的map方法，遍历返回一组JSX元素</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list=[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">msg</span>:<span class="string">&#x27;吃饭&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">msg</span>:<span class="string">&#x27;睡觉&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">msg</span>:<span class="string">&#x27;打豆豆&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">const</span> items=list.map(<span class="function">(<span class="params">item</span>)=&gt;</span></span><br><span class="line">        (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item.msg&#125;</span>&gt;</span>&#123;item.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;items&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><div class="note flat"><p>除了官方文档之外的参考文章：</p><ol><li><a href="https://juejin.cn/post/6953482028188860424">Vue 转 React不完全指北</a></li><li><a href="https://juejin.cn/post/6844904040564785159#heading-29">关于Vue和React的一些对比及个人思考(上)</a></li><li><a href="https://juejin.cn/post/6844904052812169229">关于Vue和React的一些对比及个人思考（中)</a></li><li><a href="https://juejin.cn/post/6844904183934484494#heading-5">个人理解Vue和React区别</a></li></ol></div><blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><!-- [articleName](url) --></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 框架 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网(4)-其他原理题</title>
      <link href="/2021/08/21/%E8%AE%A1%E7%BD%91(4)-%E5%85%B6%E4%BB%96%E5%8E%9F%E7%90%86%E9%A2%98/"/>
      <url>/2021/08/21/%E8%AE%A1%E7%BD%91(4)-%E5%85%B6%E4%BB%96%E5%8E%9F%E7%90%86%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<!-- <blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><p><a href="url">articleName</a></p></blockquote> --><!-- hhhh<code></code> --><h2 id="HTTP-相关"><a href="#HTTP-相关" class="headerlink" title="HTTP 相关"></a>HTTP 相关</h2><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p><img src="/static/imgForPosts/Network/4.Theory2/HTTP_Status.jpg"></p><ul><li>1xx：处理<strong>中间态</strong></li><li>2xx：成功，正确处理<ol><li><strong>「200，OK」</strong>成功，对于<code>非HEAD请求</code>，一般body携带数据</li><li><strong>「204 No Content」</strong></li><li>「206 Partial Content」应用于分块下载、断电续传</li></ol></li><li>3xx：<strong>重定向</strong><ol><li><strong>「301 Moved Permanetly」永久重定向</strong></li><li><strong>「302 Found」临时重定向</strong></li></ol><ul><li>301、302的Header里的<strong>字段Location指明跳转URL</strong></li></ul><ol start="3"><li><strong>「304 Not Modified」缓存重定向</strong>。资源未修改，重定向缓存文件。</li></ol></li><li>4xx：Client报文有误，<strong>Client错误码</strong><ol><li>「400 Bad Request」通用</li><li><strong>「403 Forbidden」</strong>Server禁止访问</li><li><strong>「404 Not Found」</strong></li></ol></li><li>5xx：<strong>Server错误码</strong><ol><li>「500 Internet Server Error」通用</li><li>「501 Not Implemented」未支持</li><li><strong>「502 Bad Gateway」</strong></li><li><strong>「503 Service Unavailable」</strong>Server忙</br></br></li></ol></li></ul><h3 id="HTTP-1-1-2-3演变简析"><a href="#HTTP-1-1-2-3演变简析" class="headerlink" title="HTTP/1.1/2/3演变简析"></a>HTTP/1.1/2/3演变简析</h3><p><img src="/static/imgForPosts/Network/4.Theory2/HTTP1~3.jpg"></p></br></br><h4 id="HTTP-1-1【顺序队头阻塞】"><a href="#HTTP-1-1【顺序队头阻塞】" class="headerlink" title="HTTP/1.1【顺序队头阻塞】"></a>HTTP/1.1【顺序队头阻塞】</h4><pre><code>- 明文，无压缩- 长连接- 顺序管道传输</code></pre></br></br><h4 id="HTTP-2【丢包全重传】"><a href="#HTTP-2【丢包全重传】" class="headerlink" title="HTTP/2【丢包全重传】"></a>HTTP/2【丢包全重传】</h4><ul><li><p>基于HTTPS</p></li><li><p>Header压缩</p><ul><li>HPACK算法：Client、Server维护<strong>头信息表【字段-索引号】</strong>，索引号通信</li></ul></li><li><p>二进制</p><ul><li>明文报文—-&gt;二进制报文<br><img src="/static/imgForPosts/Network/4.Theory2/2Radix.jpg"></li></ul></li><li><p>数据流【包非按序，流可有优先级】</p><ul><li><strong>数据流Stream</strong>：每个<strong>请求/回应的所有数据包</strong></li><li><strong>数据包非按序【需要标记】</strong></li><li>Client–奇数，Server–偶数</li><li>可以<strong>指定数据流优先级</strong></li></ul></li><li><p><strong>ServerPush,服务器推送</strong></p><ul><li><strong>改善「请求–应答」：增加Server的主动性。</strong>如可在Client刚请求时，<strong>提前发送可能用到的静态资源，减少延时等待</strong></li></ul></li><li><p><code>多路复用</code></p><ul><li>基于二进制帧实现</li><li>1.1：基于文本。如传输Hello，<strong>不能拆分传，因为Server不知道顺序</strong></li><li>2：基于数据帧。Server知道顺序，可合并成流。<strong>意味着可以并行传输</strong><br><img src="/static/imgForPosts/Network/4.Theory2/Multiplexing.jpg"></li></ul></li></ul><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><pre><code>- HTTP2的主要缺陷    + 多个HTTP请求复用1个TCP连接，TCP层不知道有多少个HTTP请求    + 当发生丢包，触发TCP重传    + 则该TCP连接的所有HTTP请求都必须等待重传</code></pre><ul><li>HTTP/3：<strong>用UDP取代TCP</strong><br>  <img src="/static/imgForPosts/Network/4.Theory2/QUIC.jpg"><ul><li>UDP：不管顺序、丢包，不可靠</li><li>Quick UDP Internet Conection：<strong>基于UDP</strong>的伪 TCP + TLS + HTTP/2 的多路复用的协议。<strong>实现可靠性传输</strong></li></ul></li></ul></br></br><h4 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h4><h5 id="明文传输对应风险与处理"><a href="#明文传输对应风险与处理" class="headerlink" title="明文传输对应风险与处理"></a>明文传输对应风险与处理</h5><ol><li><p><strong>窃听</strong>—<strong>信息加密</strong><br><img src="/static/imgForPosts/Network/4.Theory2/Eavesdrop.jpg"></p></li><li><p><strong>篡改</strong>—<strong>哈希摘要算法校验</strong><br><img src="/static/imgForPosts/Network/4.Theory2/Tamper.jpg"></p></li><li><p><strong>冒充伪装</strong>—<strong>身份证书</strong><br><img src="/static/imgForPosts/Network/4.Theory2/Pretend.jpg"></p></li></ol><h5 id="SSL-TLS建立过程"><a href="#SSL-TLS建立过程" class="headerlink" title="SSL/TLS建立过程"></a>SSL/TLS建立过程</h5><ul><li><strong>TCP连接建立后，进行SSL信用层建立</strong><br><img src="/static/imgForPosts/Network/4.Theory2/SSL1.jpg"></li></ul></br></br><p><img src="/static/imgForPosts/Network/4.Theory2/SSL2.jpg"></p><ul><li><strong>提要【下面序号为发送信息】</strong><ul><li><strong>Server公钥已交由Certificate Authrhority</strong>，证书颁发机构私钥签名，颁发给Server</li><li><strong>Server公钥「非对称」</strong>：Client用于加密master-key</li><li><strong>master-key</strong>：<code>Client生成</code>，用于生成「会话秘钥」，参考SHA算法</li><li><strong>Client/Server-Random</strong>：生成「会话秘钥」</li></ul></li></ul><ol><li>Client-Hello<strong>【加密通信请求】</strong><ul><li>1）Client支持SSL/TLS协议版本</li><li>2）Client <strong>Random</strong></li><li>3）Client的<strong>加密算法列表</strong></li></ul></li><li>Server-Hello<ul><li>1）确认SSL/TLS版本，若不支持，则关闭通信</li><li>2）Server <strong>Random</strong></li><li>3）<strong>确认加密算法</strong></li><li>4）<strong>Server的数字证书【Server公钥+CA数字签名】</strong></li></ul></li><li>Client ACK等 &amp;&amp; 处理<ul><li>验证数字证书：利用<strong>CA公钥，解析签名，对比Server公钥</strong></li><li>1）<strong>master-key：Server公钥加密后的某个随机数</strong>，参考SHA</li><li>2）加密通信改变<strong>通知</strong>：说明后续采用「会话秘钥」通信</li><li>3）<strong>握手结束通知：包含之前内容的摘要【用于Server校验】</strong></li></ul></li><li>Server ACK等 &amp;&amp; 处理<ul><li>计算会话秘钥</li><li>1）加密通信改变<strong>通知</strong></li><li>2）<strong>握手结束通知</strong></li></ul></li></ol><h2 id="Get-与-Post"><a href="#Get-与-Post" class="headerlink" title="Get 与 Post"></a>Get 与 Post</h2><ul><li>Get<ol><li>用于获取信息，无副作用</li><li><strong>幂等</strong></li><li><strong>不可缓存</strong></li><li><strong>可收藏为书签</strong></li><li><code>后退/刷新 无害</code></li></ol></li><li>Post<ol><li>用于修改服务器数据，有副作用</li><li><strong>非幂等</strong></li><li><strong>不可缓存</strong></li><li><strong>不可收藏为书签</strong></li><li><code>后退/刷新，浏览器告知数据会被重新提交</code></li></ol></li><li>传输都不安全，HTTP明文传输</li><li><strong>安全与幂等</strong><ul><li>「安全」：不会影响Server的资源</li><li>「幂等」：多次执行，结果相同。【纯函数】</li><li>GET：安全且幂等； POST：不安全、不幂等</li></ul></li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul><li>按类型分类<ul><li>DNS负载均衡</li><li>软、硬件</li></ul></li><li>Domain Name System<ul><li>不同地域的用户可通过DNS的解析，返回不同的IP地址</li><li>优缺点<ol><li>简单、拓展性差，</li><li>控制权在域名服务商</li></ol></li></ul></li><li>HTTP重定向<ul><li>通过修改HTTP-Header的Location和302临时重定向实现</li><li>优缺点<br>增加请求耗时</li></ul></li><li>反向代理<ul><li>作用于应用层，也称「七层负载均衡」，如Nginx</li><li>优缺点<ol><li>部署简单、成本低</li><li>易拓展</li></ol></li></ul></li><li>IP<ul><li>作用于网络层、传输层，也称「四层负载均衡」</li><li>通过对数据包的IP地址和Port进行修改实现，如Linux Virtual Server</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网(3)-三握四挥</title>
      <link href="/2021/08/07/%E8%AE%A1%E7%BD%91(3)-%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/"/>
      <url>/2021/08/07/%E8%AE%A1%E7%BD%91(3)-%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/</url>
      
        <content type="html"><![CDATA[<!-- <blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><p><a href="url">articleName</a></p></blockquote> --><!-- hhhh<code></code> --><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>【<strong>为了确认</strong>通信<strong>双方</strong>数据原点的<strong>序列号ISN</strong>，<strong>以保证</strong>在不可靠的信道上<strong>可靠地传输</strong>信息】</li><li>Sever监听端口：Listen状态</li><li>1）Client申请连接，发送Syn：SYN_SENT状态</li><li>2）Server，确认、并申请连接，发送ACK &amp;&amp; SYN：SYN_RECV</li><li>3）Client，确认，返回ACK：ESTABLISHED</li><li>SYN，Synchronize Sequence Numbers，同步序列信号<br><img src="/static/imgForPosts/Network/3.TCP/Shake.jpg"></li></ul><h3 id="问题与现象"><a href="#问题与现象" class="headerlink" title="问题与现象"></a>问题与现象</h3><h4 id="SYN洪水攻击（Distributed-Denial-of-Service，分布式拒绝服务）"><a href="#SYN洪水攻击（Distributed-Denial-of-Service，分布式拒绝服务）" class="headerlink" title="SYN洪水攻击（Distributed Denial of Service，分布式拒绝服务）"></a>SYN洪水攻击（Distributed Denial of Service，分布式拒绝服务）</h4><pre><code>- 原理  + 通过伪造IP大量发送SYN  + 接收服务器的SYN-ACK，但永不回复ACK  + 导致Sever的SYN【半连接】队列满  【本来Server会多次超时重传SYN，一定次数后后才会回收资源】  + 在连接建立阶段，服务器的端口会保持一段时间。用遍所有可用端口后，服务器将无法正常运行</code></pre><ul><li>解决方案<ol><li>控制队列大小、设定队列满时的处理<ul><li>设定<strong>SYN_RCVD 状态连接的最大个数</strong></li><li><strong>超出处理能力</strong>时，<strong>对新的 SYN 直接回 RST，丢弃连接</strong></li></ul></li><li>SYN-Cookies<ul><li>原理<br>  <img src="/static/imgForPosts/Network/3.TCP/SYN-Cookies.jpg"><ol><li><strong>不分配资源保存客户端信息</strong>，而是将这些信息<strong>保存在SYN+ACK的初始序号和时间戳中</strong>。对正常的连接，这些信息会随着ACK报文被带回来</li><li>当SYN队列满到一定程度后，<strong>计算并返回SYN-Cookie【不使用SYN队列】</strong></li><li><strong>接收ACK，检查合法性，直接放入Accept【连接】队列</strong></li></ol></li><li>弊端<ol><li>拒绝需要在SYN队列中协商的选项</li><li>增加了密码学运算</li></ol></li></ul></li></ol></li></ul><h4 id="不是四次握手？"><a href="#不是四次握手？" class="headerlink" title="不是四次握手？"></a>不是四次握手？</h4><pre><code>- SYN/ACK是可以合并的，提高连接速度与效率</code></pre><h4 id="不是两次握手？"><a href="#不是两次握手？" class="headerlink" title="不是两次握手？"></a>不是两次握手？</h4><pre><code>- 假设两次握手A、B分别为Client、Server- A：发送SYN + A&#39;s Initial Sequence Number- B：发送SYN + B&#39;s ISN + B&#39;s ACK of A- 表象：三次握手能避免已失效的Client连接请求，浪费Server的端口资源- 本质：A与B就A的ISN达成一致。但B的ISN未达成一致- A会超时重传ACK吗？    + TCP不会为没有数据的ACK超时重传- Server会超时重传SYN，直至接收到ACK</code></pre><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><pre><code>1)Client：停止数据传输。发送断开连接请求FIN【FIN-WAIT-1]】2)Server：返回ACK，通知进程【CLOSE-WAIT】3)Server：继续发送数据，直至完毕。发送断开请求FIN+ACK【LAST-ACK】4)Client：返回ACK【TIME-WAIT】。Server接收到则CLOSED</code></pre><p><img src="/static/imgForPosts/Network/3.TCP/Wave.jpg"></p><ul><li>2Maximum Segment Lifetime，<strong>最大报文生存周期</strong><ul><li><strong>Client</strong>在发送最后一个ACK后，<strong>需要等待2MSL后，才能进入CLOSED状态</strong></li><li>2MSL是最后一个ACK和Server可能再次发送的FIN的最长时间</li><li><strong>保证最后一个ACK的到达</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网(2)-原理题</title>
      <link href="/2021/07/31/%E8%AE%A1%E7%BD%91(2)-%E5%8E%9F%E7%90%86%E9%A2%98/"/>
      <url>/2021/07/31/%E8%AE%A1%E7%BD%91(2)-%E5%8E%9F%E7%90%86%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<!-- <blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><p><a href="url">articleName</a></p></blockquote> --><!-- hhhh<code></code> --><h1 id="URL输入到页面呈现的全过程"><a href="#URL输入到页面呈现的全过程" class="headerlink" title="URL输入到页面呈现的全过程"></a>URL输入到页面呈现的全过程</h1><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol><li>URL解析：解析http协议、端口、资源地址</li><li>DNS查询：查询本地DNS，在访问DNS服务器将域名解析成IP</li><li>传输（TCP为例）</li><li>Server接收请求并处理，返回响应</li><li>Client接收响应，渲染页面</li></ol><h2 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h2><ul><li>scheme://host.domain:port/path/filename</li><li><strong>协议：//域主机.域名:主机端口/资源路径/资源名称</strong></li><li><a href="https://www.baidu.com/">https://www.baidu.com</a></li></ul><h2 id="DNS查询【真实地址查询】"><a href="#DNS查询【真实地址查询】" class="headerlink" title="DNS查询【真实地址查询】"></a>DNS查询【真实地址查询】</h2><ul><li>浏览器缓存</li><li>本地缓存，hosts</li><li>路由缓存</li><li>DNS服务器</li><li>递归与迭代查询：<ul><li>递归：被请求者必须给请求者一个答复，会向别的服务器发送请求</li><li>迭代：被请求这只需告诉请求者找谁咨询<br><img src="/static/imgForPosts/Network/2.Theory/searchDNS.jpg"></li></ul></li></ul><h2 id="传输【全双工通信、TCP】"><a href="#传输【全双工通信、TCP】" class="headerlink" title="传输【全双工通信、TCP】"></a>传输【全双工通信、TCP】</h2><ul><li>注意：TCP/IP分为4层，<strong>每层都会添加/解析头部</strong><br><img src="/static/imgForPosts/Network/2.Theory/Header.jpg"></li></ul><h3 id="大致流程-1"><a href="#大致流程-1" class="headerlink" title="大致流程"></a>大致流程</h3><pre><code>1. 通过IP协议，**解析得源、目标地址**2. 通过OpenShortestPathFirst，开放式路径最短优先，**计算路由最短路径**3. 通过AddressResolutionProtocol，地址解析协议，**计算路由MAC地址**4. **启动端口**，与对应目标主机通过TCP三次握手，**建立连接**5. 请求下载页面，**根据响应状态码执行对应行为**</code></pre><h3 id="应用层：发送HTTP请求"><a href="#应用层：发送HTTP请求" class="headerlink" title="应用层：发送HTTP请求"></a><strong>应用层：发送HTTP请求</strong></h3><pre><code>- 请求行：请求方法、URL、协议版本- 请求头- 请求体：附在URL/body</code></pre><h3 id="传输层：TCP传输报文"><a href="#传输层：TCP传输报文" class="headerlink" title="传输层：TCP传输报文"></a><strong>传输层：TCP传输报文</strong></h3><ol start="0"><li><p><strong>解决以下问题:</strong></p></li><li><p><strong>可靠传输</strong></p><ul><li><strong>确认ACK和超时重传</strong><ol><li>ACK。建立连接会生成随机首位序列号，依次标记数据<br><img src="/static/imgForPosts/Network/2.Theory/ACK.jpg"></li><li>超时重传<ul><li>数据包丢失：A重发</li><li>ACK丢失：A多发，B去重。累积次数，认为异常，断开。<br/><br/>  </li></ul></li></ol></li></ul></li><li><p><strong>TCP拥塞控制【全局性调控，避免雪崩】</strong></p><ul><li><p>网络拥塞</p><ul><li>指在分组交换网络中，传送分组的数目过多时，由于存储转发节点的资源有限，导致网络传输性能下降的情况</li></ul></li><li><p>运作方法</p><ul><li>动态<strong>cwnd，拥塞窗口；sthresh，阈值</strong>；Rount-Trip Time，往返时间<br><img src="/static/imgForPosts/Network/2.Theory/Congestion.jpg"></li></ul></li><li><p><code>慢启动算法</code>【成倍、类似指数】</p></li><li><p><code>拥塞避免算法</code>【线性】</p><ul><li>当文段计时器超时【超时重传】，<code>cwnd重置，启动慢开始，ssthresh减半</code><br><img src="/static/imgForPosts/Network/2.Theory/Congestion2.jpg"></li></ul></li><li><p>线增积减【即上图的cwnd变化方式】</p></li><li><p><strong>快重传</strong><code>【避免误判拥塞，重置cwnd】</code></p><ul><li>接收方收到非顺序包，会重复ACK<br><img src="/static/imgForPosts/Network/2.Theory/Retransmit.jpg"></li></ul></li><li><p><strong>快恢复</strong></p><ul><li>ssthresh = cwnd / 2， cwnd = ssthresh<br><img src="/static/imgForPosts/Network/2.Theory/Recover.jpg"></li></ul></li><li><p><strong>流量控制【点对点通信量的控制】</strong></p><ul><li>运作方法<ul><li><strong>Receiver</strong>返回的<strong>ACK</strong>包含<strong>自己的cwnd大小</strong></li></ul></li><li><code>死锁</code><ul><li>当<strong>Sender收到cwnd = 0的ACK</strong>时，<strong>停止发送</strong>，等待下一个应答</li><li>假设Receiver下一个非0应答，一直丢失。误以为Sender已接收</li><li>此时，<strong>Sender在等待应答，Receiver在等待接收新数据</strong></li></ul></li><li><code>处理方法：</code><ul><li>TCP使用<strong>持续计时器</strong></li><li><strong>每当Sender收到 cwnd = 0的应答，启动计时</strong></li><li><strong>计时完毕，Sernder主动询问</strong>cwnd大小</li><li>若cwnd = 0：重置计时</li><li>若 cwnd ≠ 0：<strong>应答报文丢失，重置</strong>发送窗口，开始<strong>发送</strong></li></ul></li></ul></li><li><p><code>区别</code></p><ul><li><strong>拥塞控制：作用于网络全局。</strong>防止过多数据注入到网络中，出现网络负载过重的情况 <strong>【减少网络压力】</strong></li><li><strong>流量控制：作用于Receiver。</strong>通过控制Sender的速度，使得Receiver来得及接收，防止分组丢失 <strong>【保证端对端通信完整性】</strong></li></ul></li></ul></li></ol><h3 id="网络层：IP协议-查询-Media-Access-Control-address地址【网卡物理地址】"><a href="#网络层：IP协议-查询-Media-Access-Control-address地址【网卡物理地址】" class="headerlink" title="网络层：IP协议 查询 Media Access Control address地址【网卡物理地址】"></a>网络层：IP协议 <strong>查询</strong> Media Access Control address地址【网卡物理地址】</h3><pre><code>- 数据打包，加入源、目标IP- 路由表查询下一跳- 直至目标在网络中，使用ARP查询MAC地址发送</code></pre><h3 id="链路层：以太网协议"><a href="#链路层：以太网协议" class="headerlink" title="链路层：以太网协议"></a>链路层：以太网协议</h3><pre><code>- 将数据分为“帧”为单位的数据包    + 标头：发送者、接受者、数据类型    + 数据：内容</code></pre><h3 id="三握四挥"><a href="#三握四挥" class="headerlink" title="三握四挥"></a>三握四挥</h3><p>见这篇文章：<a href="/%E8%AE%A1%E7%BD%91(3)-%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.html">【三握四挥】</a></p><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><pre><code>1. HTML解析DOM树2. CSS解析CSS样式树3. 结构DOM与CSS树，生成渲染树4. 根据渲染树计算每个节点的信息5. 根据节点信息绘制渲染画面</code></pre><ul><li>回流与重绘 <strong>【回流一定会触发重绘，而重绘不一定会回流】</strong><ul><li>RenderTree的Node<ol><li>display：none。不存在Render树上</li><li>存在Render树上，但不可见<ul><li>visibility：hidden</li><li>opacity：0</li></ul></li></ol></li><li>根据RenderTree，进行Layout回流，得到节点<strong>几何信息</strong>（位置大小）</li><li>Painting，重绘：根据RenderTree和layout的几何信息，得到<strong>节点的绝对像素</strong></li><li>Display：像素发送给GPU，合成展示</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网(1)-概念</title>
      <link href="/2021/07/17/%E8%AE%A1%E7%BD%91(1)-%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/07/17/%E8%AE%A1%E7%BD%91(1)-%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<!-- <blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><p><a href="url">articleName</a></p></blockquote> --><!-- hhhh<code></code> --><h1 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h1><ol><li><strong>应用层</strong>：通过应用进程的交互完成网络应用<ul><li>应用层：应用服务</li><li>表示层：数据格式化、代码转换</li><li>会话层：解除/建立与别的点的联系</li></ul></li><li><strong>传输层</strong>：端（进程）到端的通信</li><li><strong>网络层</strong>：选择合适的网间路由和交换节点，完成主机之间的通信<ul><li>IP协议<ul><li>屏蔽下层物理网络差异，提供统一的IP数据报</li><li><strong>无连接</strong></li><li>不可靠：丢失，路由发送ICMP报文，必要时由TCP纠错</li><li>尽力：分段封装</li></ul></li><li>Adress Resolution P</li></ul></li><li><strong>数据链路层</strong>：封装帧、链路层地址（MAC地址）<ul><li>数据链路层</li><li>物理层</li></ul></li></ol><h1 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ol><li><strong>Hyper Text Tansfer Protocol，超文本传输协议</strong>。运行在TCP之上，指定客户端可能发送给服务器什么信息、得到什么响应</li><li><strong>File Transfer P，文件传输协议</strong><br><img src="/static/imgForPosts/Network/1.Concept/FTP.jpg"><ul><li>应用层协议之一</li><li>FTP<strong>服务器用来存储文件</strong></li><li>传输效率高，一般传输大文件</li></ul></li><li><strong>Domain Name System，域名系统</strong><br><img src="/static/imgForPosts/Network/1.Concept/DNS.jpg"><ul><li>由于IP地址是计算机识别的地址，为方便人类访问，映射成域名</li></ul></li><li><strong>Telnet，远程登录协议</strong><br><img src="/static/imgForPosts/Network/1.Concept/Telnet.jpg"><ul><li>允许用户通过一个协商过程，与另一个远程设备进行通信</li><li>为用户提供了在本地，完成远程主机工作的能力</li></ul></li><li><strong>SecureShell，SSH，安全外壳协议</strong><ul><li>建立在应用层上的安全加密协议</li><li>Telnet的<strong>明显缺点：数据包明文传输</strong></li><li>为了数据安全，一般用SSH远程登录</li></ul></li></ol><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ol><li><strong>Transimisson Control Protocol，传输控制协议</strong>：面向连接的、可靠的传输层通信协议</li><li><strong>User Datagram P，用户数据报协议</strong>：无连接</li><li><strong>Real-time Transport P，实时传输协议</strong></li></ol><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ol><li><strong>Internet P，网际协议</strong>：规定路由和端系统之间传输的分组格式</li><li><strong>Inter Control Message P，控制报文协议</strong>：告知<strong>网络包传送过程中</strong>产生的<strong>错误</strong>以及各种<strong>控制信息</strong></li><li><strong>Address Resolution P，地址解析协议</strong>：将IP和MAC地址相互映射</li></ol><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h1 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h1><ol><li><strong>Socket套接字接口</strong>：规定端系统之间通过Internet进行数据交换的API</li><li><strong>时延</strong>：指报文/分组从网络一段传到另一端所需的时间。<strong>总时延 = 发送 + 传播 + 处理 + 排队</strong><ul><li><strong>发送</strong>：数据量/发送速率</li><li><strong>传播</strong>：波环境传播用时</li><li><strong>处理</strong>：路由或其他端收到分组处理时间</li><li><strong>排队</strong>：分组在进入路由前需要在输入队列中排队</li></ul></li><li><strong>吞吐量</strong>：单位时间内成功传输的数据量</li><li><strong>Datagram</strong>，数据报：网络层的分组</li><li><strong>Message</strong>，报文段：传输层的分组</li><li><strong>Frame，帧</strong>：链路层的分组</li><li><strong>Classless Internet Domain Routing，无类别区间路由</strong>：一种对IP地址进行归类的方法</li><li><strong>端口号</strong>：在一台主机内，用于标识不同的APP进程</li><li><strong>Uniform Resource Identifier，统一资源标识符</strong>。唯一地标记网上资源<br><img src="/static/imgForPosts/Network/1.Concept/URL.jpg"><ul><li>Uniform Resource Locator，统一资源定位符。</li><li>URName</li></ul></li><li><strong>Session</strong><ul><li>Client会话的缓存，为弥补HTTP无状态特性而设计的</li><li>Server可以利用Session存储Client在<strong>同一个会话间</strong>的操作记录</li><li>当Client请求时，<strong>Server</strong>会<strong>为该请求开辟一块对象内存</strong>，Seesion对象，来保存操作记录。</li></ul></li><li><strong>Cookies</strong><ul><li>HTTP协议中包括<strong>Web Cookie</strong>和<strong>浏览器Cookie</strong></li><li>是<strong>Server发送</strong>到浏览器的小块数据</li><li>浏览器会进行存储，<strong>并与下一个请求一起发送到服务器</strong></li><li>通常，用于判断来个请求是否来自于同一个浏览器【用户保持登录状态】</li></ul></li><li><strong>多路分解</strong><ul><li><strong>接收端的运输层：</strong><ul><li><strong>检查</strong>源、目的端口号等<strong>字段</strong></li><li><strong>标识</strong>出<strong>接收</strong>的<strong>套接字</strong></li><li>从而将运输层的<strong>数据交付</strong>到正确套接字的<strong>过程</strong></li></ul></li></ul></li><li><strong>多路复用</strong><ul><li>发送方：<ul><li>从<strong>不同的套接字收集数据</strong></li><li>为数据块<strong>封装</strong>上<strong>首部信息</strong>，生成报文段</li><li>然后将报文段<strong>传递给网络层的过程</strong></li></ul></li></ul></li><li><strong>单工，半、全双工</strong><ul><li>单工：单向通信。广播</li><li>半双工：允许双向，但同一时间，只能单向通信。对讲机</li><li>全双工：双向同时传输。手机通话</li></ul></li></ol><h1 id="体系相关"><a href="#体系相关" class="headerlink" title="体系相关"></a>体系相关</h1><ol><li><p><strong>体系</strong></p><ul><li><strong>Client-Server体系</strong>：一种面向网络APP的体系结构。Client发送服务请求，Server完成服务，返回响应。Server通常是大型服务器集群</li><li><strong>P2P体系</strong>：端系统之间对等，可以请求、响应</li><li><strong>分布式APP</strong>：多个端系统之间相互交换数据的APP</li><li><strong>中心化</strong>是<strong>分布式网络结构</strong>中的<strong>一种</strong>，所有的<strong>去中心化</strong>都是<strong>采用分布式网络</strong>结构的<br><img src="/static/imgForPosts/Network/1.Concept/Distributed.jpg"></li></ul></li><li><p><strong>Content Delivery Network，内容分发网络</strong></p><ul><li>应用了HTTP协议里的<strong>缓存和代理技术</strong>，<strong>代替源站</strong>响应Client的请求</li><li>构建在<strong>现有网络基础上的网络</strong>。</li><li>依靠<strong>部署在各地</strong>的<strong>边缘服务器</strong>，通过<strong>中心平台的负载均衡</strong>、内容分发、调度等功能模块</li><li>实现使用户<strong>就近获取内容</strong>、降低网络堵塞、提高用户访问<strong>响应速度和命中率</strong></li></ul></li><li><p>Web App Firewall，Web应用防火墙。<strong>应用层面的防火墙</strong>，<strong>专门检测HTTP流量</strong>。通过执行一系列针对HTTP/HTTPS的安全策略实现</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网|自顶向下|概述</title>
      <link href="/2021/07/03/%E8%AE%A1%E7%BD%91(0)-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/07/03/%E8%AE%A1%E7%BD%91(0)-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="核心观点"><a href="#核心观点" class="headerlink" title="核心观点"></a>核心观点</h1><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>首先，我们要明确两个概念【功能】与【服务】</p><ul><li>功能：是拥有的能力</li><li>服务：是功能的体现</li></ul><p>在计网中，有很明显的分层特性：</p><ul><li>每层【功能】基于下层的【服务】，协调软硬件实现</li><li>每层通过接口给上层提供【服务】</li></ul><h1 id="分层简介【对等层逻辑来看】"><a href="#分层简介【对等层逻辑来看】" class="headerlink" title="分层简介【对等层逻辑来看】"></a>分层简介【对等层逻辑来看】</h1><ul><li>应用层<ul><li>主要协议：Hyper TextTP、FileTP、Simple Mail TransferP</li><li>基于传输层应用进程间通信，实现：<strong>不同类型应用间的通信</strong></li></ul></li><li>传输层<ul><li>主要协议：Transmission ControlP【偏向可靠性】、User DatagramP【偏向实时性】</li><li>基于网络层端到端【E2E，源to目标主机】通信，实现：<strong>应用进程的通信</strong>，并<strong>根据偏向性提供加强服务</strong></li></ul></li><li>网络层<ul><li>主要协议：<ul><li>InternetP</li></ul></li><li>基于数据链路层点到点【P2P】通信，实现：<strong>End2E【源to目标主机】的Package为单位的数据通信</strong></li><li>特性：Best Ever,尽力而为，不保证</li><li>解决方案：<ul><li>传统的IP+路由【固定、功能拓展性低】<ol><li>路由协议交换路由信息</li><li>路由算法计算路由表</li><li>IP协议基于路由表对到来的IP分组做转发处理</li></ol></li><li>现代的Software Defined Network【功能集合丰富、灵活】<ol><li>控制平面【网络操作系统】<ul><li>基于不同的网络应用计算FlowTable【各种字段MAC、IP等】</li><li>将FlowTable，流表下发给switch</li></ul></li><li>数据平面【switch，交换机】<ul><li>基于FlowTable对分组匹配、操作</li><li>实现不同的功能：防火墙、路由转发等</li></ul></li></ol></li></ul></li></ul></li><li>数据链路层与局域网【网卡、WLAN等】<ul><li>基于物理层模数转换、物理信号传输，实现：<strong>相邻两点Point2P的帧为单位的数据通信</strong></li></ul></li><li>物理层<ul><li>基于Media介质实现：<strong>模数转换、物理信号传输实现bit为单位的数据通信</strong></li></ul></li></ul><h1 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h1><h2 id="什么是【协议】Protocol"><a href="#什么是【协议】Protocol" class="headerlink" title="什么是【协议】Protocol"></a>什么是【协议】Protocol</h2><ul><li>对等层实体通信所遵守的规则：语法、语义、时序</li></ul><h2 id="什么是【互联网-网际】Internet"><a href="#什么是【互联网-网际】Internet" class="headerlink" title="什么是【互联网/网际】Internet"></a>什么是【互联网/网际】Internet</h2><ol><li><p>网络</p><ul><li>基于点、边组成的与大小、形状无关的拓扑结构</li></ul></li><li><p>计算机网络</p><ul><li>联网的计算机组成的系统</li><li>节点：<ul><li>主机节点：源、目标</li><li>数据交换节点：转发。包括路由器、交换机【交换机在不同的层有不同的实现：中继器、switch、负载均衡设备】</li></ul></li><li>链路：<ul><li>接入网链路：主机节点接入网的链路</li><li>主干链路：数据交换节点间的链路</li></ul></li></ul></li><li><p>Internet</p><ul><li>基于IP、TCP等一簇协议，实现的一种网网互联的计算机网络</li><li>从服务角度看<ol><li>分布式应用</li><li>为分布式应用提供通信服务的基础设施<ul><li>无连接不可靠</li><li>面向连接可靠</li><li>区分：【见分组交换】<ul><li>面向连接：端维护源、目的地址，路径不固定</li><li>有连接：建立链接，路径固定</li></ul></li></ul></li></ol></li></ul><p> <img src="/static/imgForPosts/Network/0.Summary/InternetInService.jpeg"></p><ul><li>从结构角度看【3个子系统】<ol><li>网络边缘</li><li>网络核心</li><li>接入网、Meida物理媒体</li></ol></li></ul><p> <img src="/static/imgForPosts/Network/0.Summary/InternetInStructure.jpeg"></p></li></ol><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><ul><li>端系统【主机】</li><li>应用交互模型<ol><li>C/S模型：Client请求，Server响应</li><li>Peer2P模型：每个端可请求、响应<h2 id="接入网、Media物理媒体"><a href="#接入网、Media物理媒体" class="headerlink" title="接入网、Media物理媒体"></a>接入网、Media物理媒体</h2></li></ol></li><li>有线/无线</li><li>共享/独享</li><li>Media<ul><li>导引型：光纤、双绞线</li><li>非导引型：无线电磁波</li></ul></li></ul><h2 id="网络核心：分组交换、线路交换"><a href="#网络核心：分组交换、线路交换" class="headerlink" title="网络核心：分组交换、线路交换"></a>网络核心：分组交换、线路交换</h2><ul><li>路由和交换机等组成的数据交换网络</li><li>关键功能：<ol><li>路由：计算路由表（路径、跳点等）</li><li>转发：将Package转发到输出链路</li></ol></li></ul><p><img src="/static/imgForPosts/Network/0.Summary/CoreInternet.jpeg"></p><ul><li>数据怎么在网络核心传输？<ol start="0"><li>计算机通信特点：<ul><li>突发性</li><li>间歇性</li></ul></li><li>电路交换（预约服务）<ul><li>原理：通信两端之间分配一条链路、独享资源</li><li>实例：传统固话</li><li>链路（带宽）分片方法：【λ=u/f，波长=波速/频率】<ol><li>频分，Frequency-Division-Multiplexing</li><li>时分，Time</li><li>波分，Wave</li></ol></li><li>用时：建立链接+传输时间+传播延时</li><li>不适合：<ol><li>建立链接用时长</li><li>计算机通信突发性，链路资源会被浪费</li></ol></li></ul></li><li>分组交换（按需服务）<ul><li>原理：<ol><li>数据分为一个个Package</li><li>网络带宽资源不再分片，传输使用全部带宽</li><li>每个<strong>转发节点</strong>进行<strong>存储、转发</strong>的过程。实现整个链路带宽资源每个部分使用时独占，不使用时共享</li></ol></li><li>用时例子：需要在接收到一个完整的Package，再进行处理</li><li>用时：传输时间+传播时延+Package处理时间+排队时延</li><li>排队和丢失：<ul><li>Package会排队、等待传输</li><li>路由缓存用完，Package将会被丢弃</li></ul></li><li>复用：Statistical Time DM,统计时分多路复用<ul><li>时分复用：固定分配时间片，不管是否发送数据</li><li>统计时分：按需分配，只要需要，就分配时隙</li></ul></li><li>网络分类<ul><li>Datagram：面向连接</li><li>Virtual Circuit，虚拟电路：有链接</li></ul></li></ul></li><li>VS<br><img src="/static/imgForPosts/Network/0.Summary/PackageChange.jpeg"></li></ol></li></ul><h2 id="Internet-ISP结构"><a href="#Internet-ISP结构" class="headerlink" title="Internet/ISP结构"></a>Internet/ISP结构</h2><ul><li>Internet Service Provider</li><li>IContentP</li><li>I（X）ExchangeP</li><li>Data Center,有些大公司在ISP附近建立自己的DC,通过ISP连接其他DC，提供高速内容服务</li><li>tier1：国际；2：区域；3…：本地<br><img src="/static/imgForPosts/Network/0.Summary/ISP.jpeg"></li></ul><h2 id="性能：丢包、延时、吞吐量"><a href="#性能：丢包、延时、吞吐量" class="headerlink" title="性能：丢包、延时、吞吐量"></a>性能：丢包、延时、吞吐量</h2><ul><li>丢包<ul><li>路由缓存队列满—&gt;丢弃新的Package</li><li>根据链路、源主机的可靠性决定本身是否重传Package</li></ul></li><li>4种Package延时<ol><li>节点处理延时，Nodal-Processing-Delay</li><li>排队延时，Queueing<ul><li>流量强度：I=La/R：R流量rbps、L每秒分组数、a分组大小【0&lt;=I&lt;1】【预判流量强度，队列堵塞概率，见VS】</li></ul></li><li>传输延时，Transimission<ul><li>Internet Control MessageP,控制报文协议<ul><li>用于在IP主机、路由器之间传递控制信息</li><li>控制信息：网络是否通、目标主机是否可达、路由是否可用等</li></ul></li></ul></li><li>传播延时，Propagation<ul><li>物理介质传播延时</li></ul></li></ol></li><li>吞吐量，<strong>Through</strong>Put<ul><li>设备单位时间处理的<strong>有效</strong>数据量【如接收并转发】</li><li>带宽,Max Netbitrate：链路单位时间传输最大数据量<br><img src="/static/imgForPosts/Network/0.Summary/PackageDelay1.jpeg"><br><img src="/static/imgForPosts/Network/0.Summary/PackageDelay2.jpeg"></li></ul></li></ul><h2 id="协议层次、服务模型"><a href="#协议层次、服务模型" class="headerlink" title="协议层次、服务模型"></a>协议层次、服务模型</h2><ul><li><p>设计实现复杂功能</p><ul><li>功能明确分层（相邻层间调用、服务）【√】</li><li>模块化</li></ul></li><li><p>分层优劣</p><ul><li>优点：<ul><li>功能分拆、独立设计实现</li><li>便于每层技术平滑升级</li></ul></li><li>缺点：<ul><li>信息交换效率较低</li></ul></li></ul></li><li><p>服务模型</p><ul><li>面向连接的服务【通信前：需要连接、准备资源】</li><li>无连接的服务</li></ul></li><li><p>数据单元，DU</p><ul><li>根据大小组合、拆分</li><li>ServiceDU从上层传输–&gt;加工【拆分、组合】–&gt;添加头部信息–&gt;ProtocolDU</li><li>应用层：Message</li><li>传输层：Segment</li><li>网络层：Package/Datagram</li><li>数据链路层：Frame帧</li><li>物理层：bit</li></ul></li></ul><p><img src="/static/imgForPosts/Network/0.Summary/DataUnit1.jpeg"></p><ul><li>DU封装与解封装<br><img src="/static/imgForPosts/Network/0.Summary/DataUnit2.jpeg"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS现代教程(4)</title>
      <link href="/2021/06/26/JS%E7%8E%B0%E4%BB%A3%E6%95%99%E7%A8%8B(4)/"/>
      <url>/2021/06/26/JS%E7%8E%B0%E4%BB%A3%E6%95%99%E7%A8%8B(4)/</url>
      
        <content type="html"><![CDATA[<!-- <blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><p><a href="url">articleName</a></p></blockquote> --><!-- hhhh<code></code> --><!-- 见这篇文章：[【三握四挥】](/计网(3)-三握四挥.html) 以post文件夹为起点，也可以设置自身文章连接--><h2 id="原型与继承相关"><a href="#原型与继承相关" class="headerlink" title="原型与继承相关"></a>原型与继承相关</h2><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><ol><li><strong>特殊属性<code>[[Prototype]]</code>：null/被继承对象的引用</strong></br></li><li><code><em>proto</em></code>是<code>[[Prototype]]</code>的getter和setter<ul><li>现多用<code>Object.getPrototypeOf/Object.setPrototypeOf</code>替代</br></li></ul></li><li><strong>方法是共享的，但对象状态不是【this指向不受影响】</strong></br></li><li>for…in循环也会<strong>迭代原型链上所有的属性【可枚举enumerable】</strong><ul><li>使用hasOwnProperty（key）过滤<br><img src="/static/imgForPosts/JavaScript/ModernCourse/inherit1.jpg"></br></li></ul></li><li><strong>几乎所有其他键/值获取方法都忽略继承属性</strong><ul><li><code>object.keys/values</code>等</br></li></ul></li><li>继承链<ul><li>animal是对象**字面量{…}**，默认从<code>object.prototype</code>继承。<code>Object.prototype.hasOwnProperty</code>是<code>enumerable：false</code>的<br><img src="/static/imgForPosts/JavaScript/ModernCourse/inherit2.jpg"></br></li></ul></li><li>共享一个“胃”<ul><li><strong>简单的赋值</strong><code>this.stomach=[food]</code><strong>不会执行属性查找，而是写入this对象</strong></br></li><li>描述特定对象状态的属性stomach，应该被写入对象<br><img src="/static/imgForPosts/JavaScript/ModernCourse/inherit3.jpg"></li></ul></li></ol><br/><br/><h3 id="F-prototype普通属性"><a href="#F-prototype普通属性" class="headerlink" title="F.prototype普通属性"></a>F.prototype普通属性</h3><ol><li><strong>为new F()的Prototye赋值,Function独有</strong></br></li><li>默认值：只有属性constructor的对象，constructor指向函数自身<br><img src="/static/imgForPosts/JavaScript/ModernCourse/prototype1.jpg"></br></li><li>当有一个对象，不清楚构造器。通过constructor创建类似对象<br><img src="/static/imgForPosts/JavaScript/ModernCourse/prototype2.jpg"></br></li><li>为了确保正确的 “constructor”，我们可以选择添加/删除属性到默认 “prototype”，而不是将其整个覆盖<br><img src="/static/imgForPosts/JavaScript/ModernCourse/prototype3.jpg"></li></ol><h3 id="修改prototype"><a href="#修改prototype" class="headerlink" title="修改prototype"></a>修改prototype</h3><ol><li><strong>所有delete操作直接应用于对象</strong>，不会查找<br><img src="/static/imgForPosts/JavaScript/ModernCourse/delproto.jpg"></li></ol><br/><br/><h3 id="原生的原型"><a href="#原生的原型" class="headerlink" title="原生的原型"></a><strong>原生的原型</strong></h3><ol><li><strong>一切都从对象继承而来</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/native1.jpg"></br></li><li>基本数据类型<ul><li><strong>null、undefined没有对象包装器—-&gt;没有方法和属性、相应的原型</strong></br></li><li>它们不是对象</br></li><li>当我们<strong>试图访问它们的属性</strong>，那么<strong>临时包装器对象</strong>，将会通过<strong>内建的构造器</strong>String、Number和Boolean<strong>创建。提供操作方法后销毁</strong></br></li><li>String.prototype、Number.prototype 和 Boolean.prototype 进行获取</br></li></ul></li><li>从原型中借用<ul><li><strong>join 的内部算法只关心正确的索引和 length 属性。不检查是否为数组</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/native2.jpg"></li></ul></li></ol><br/><br/><h3 id="原型方法，没有-proto-的对象"><a href="#原型方法，没有-proto-的对象" class="headerlink" title="原型方法，没有_proto_的对象"></a>原型方法，没有_proto_的对象</h3><ol><li>替代_proto_的方法<ul><li>三个<br><img src="/static/imgForPosts/JavaScript/ModernCourse/protoMethod1.jpg"></br></li><li>Object.create()<strong>为新对象提供额外属性【默认不可枚举！】</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/protoMethod2.jpg"></br></li><li>Object.create()实现比<strong>for…in更强大的对象克隆【所有属性：可、不可枚举的，数据属性和setters/getters–并有正确的<code>[[Prototype]]</code>】</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/protoMethod3.jpg"></br></li></ul></li><li>Object.prototype的其他方法<ul><li>注意可枚举/所有，返回是否为数组<br><img src="/static/imgForPosts/JavaScript/ModernCourse/protoMethod4.jpg"></li></ul></li></ol><br/><br/><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ol><li>try…catch<ul><li><strong>try..catch 同步工作</strong>；try..catch 包裹了计划要执行的函数，该函数本身要稍后才执行， 这时引擎已经离开了 try..catch 结构。<br><img src="/static/imgForPosts/JavaScript/ModernCourse/errHandle1.jpg"></br></li><li>修正<br><img src="/static/imgForPosts/JavaScript/ModernCourse/errHandle2.jpg"></li></ul></li></ol><br/><br/><h3 id="Promise，async-await"><a href="#Promise，async-await" class="headerlink" title="Promise，async/await"></a>Promise，async/await</h3><ol><li><strong>Promise API【5】</strong><ul><li><code>Promise.all</code>（promises）<strong>【接收Iterable】</strong><ul><li>等待所有 promise 都 resolve 时，返回存放它们结果的数组。任一rejecte返回Promise.all 的 error，其他 promise 的结果都会被忽略</li><li>返回数组顺序同源顺序<br><img src="/static/imgForPosts/JavaScript/ModernCourse/promise1.jpg"></br></li></ul></li><li><code>Promise.allSettled</code>（promises）<strong>【不论结果都等待返回】</strong><ul><li>等待所有 promise 都 settle 时，并以包含以下内容的对象数组的形式返回它们的结果：</li><li>status: “fulfilled” 或 “rejected”</li><li>value（如果 fulfilled）或 reason（如果 rejected）<br><img src="/static/imgForPosts/JavaScript/ModernCourse/promise2.jpg"></br></li></ul></li><li><code>Promise.race</code>（promises）<ul><li>等待第一个 settle 的 promise，并将其 result/error 作为结果<br><img src="/static/imgForPosts/JavaScript/ModernCourse/promise3.jpg"></br></li></ul></li><li><code>Promise.resolve</code>（value）<ul><li>使用给定 value 创建一个 resolved 的 promise</br></li></ul></li><li><code>Promise.reject</code>（error）<ul><li>使用给定 error 创建一个 rejected 的 promise</br></li></ul></li></ul></li><li>async/await<ul><li>async的作用<ul><li>让这个函数总是返回一个 promise</li><li>允许在该函数内使用 await</br></li></ul></li><li>async/await <strong>可以和 Promise.all 一起使用</strong><ul><li>try..catch 在调用周围捕获到的异常（exception）。<br><img src="/static/imgForPosts/JavaScript/ModernCourse/async1.jpg"></br></li></ul></li><li>async/await<strong>重写rethrow</strong><ul><li>【注意HttpError的定义，try…catch，while循环的退出】<br><img src="/static/imgForPosts/JavaScript/ModernCourse/async2.jpg"><br><img src="/static/imgForPosts/JavaScript/ModernCourse/async3.jpg"></br></li></ul></li><li>在非async函数中调用async函数<ul><li>只需要把 async 调用当作 promise 对待，并在它的后面加上 .then<br><img src="/static/imgForPosts/JavaScript/ModernCourse/async4.jpg"></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS现代教程(3)</title>
      <link href="/2021/06/12/JS%E7%8E%B0%E4%BB%A3%E6%95%99%E7%A8%8B(3)/"/>
      <url>/2021/06/12/JS%E7%8E%B0%E4%BB%A3%E6%95%99%E7%A8%8B(3)/</url>
      
        <content type="html"><![CDATA[<!-- <blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><p><a href="url">articleName</a></p></blockquote> --><!-- hhhh<code></code> --><!-- 见这篇文章：[【三握四挥】](/计网(3)-三握四挥.html) 以post文件夹为起点，也可以设置自身文章连接--><h2 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h2><ul><li>原先：JS只有全局、函数作用域</li><li>增加：块作用域：<strong>由&#123;&#125;包括</strong>：<code>if、for控制流程语句</code>的{}属于块作用域【<code>控制流程语句的有效范围</code>】</li></ul><h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="递归与堆栈"><a href="#递归与堆栈" class="headerlink" title="递归与堆栈"></a>递归与堆栈</h3><ol><li>context执行上下文和堆栈<ul><li>一个函数进行嵌套调用时，将发生：<br><img src="/static/imgForPosts/JavaScript/ModernCourse/context1.jpg"><br/></li></ul></li><li>链表<br> <img src="/static/imgForPosts/JavaScript/ModernCourse/context2.jpg"><br> <img src="/static/imgForPosts/JavaScript/ModernCourse/context3.jpg"></li></ol><br/><br/><h3 id="Rest参数（…）与Spread语法（…）【展开运算符】"><a href="#Rest参数（…）与Spread语法（…）【展开运算符】" class="headerlink" title="Rest参数（…）与Spread语法（…）【展开运算符】"></a>Rest参数（…）与Spread语法（…）【展开运算符】</h3><ol><li><p>Rest</p><ul><li>出现在函数参数列表的最后，把<strong>剩余的参数</strong>收集到一个<strong>数组</strong>中<br><img src="/static/imgForPosts/JavaScript/ModernCourse/spread1.jpg"><br/></li></ul></li><li><p>arguments变量—-类数组，<strong>按参数索引</strong>包含所有参数</p><ul><li><strong>箭头函数没有自身的this和arguments对象</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/spread2.jpg"><br/></li></ul></li><li><p>Spread</p><ul><li>Array.from—&gt;iterable对象、类数组</li><li>Spread—-&gt;iterable对象</li></ul></li></ol><br/><br/><h3 id="变量作用域、闭包"><a href="#变量作用域、闭包" class="headerlink" title="变量作用域、闭包"></a>变量作用域、闭包</h3><ol><li><p><strong>什么是闭包？【闭包定义，解释为什么<code>JS所有函数都是闭包【一个例外】</code>，以及可能的关于[[Envioronment]]属性和词法环境原理的技术细节】</strong></p><ul><li><p><code>例外：new Function</code>，<code>[[Environment]]</code>指向<code>全局环境</code><br><img src="/static/imgForPosts/JavaScript/ModernCourse/closure1.jpg"><br/></p></li><li><p><strong>定义</strong>：闭包指<strong>内部函数</strong>总是可以，访问<strong>其所在的外部函数中声明的变量和参数</strong>，即使在其外部函数被返回（寿命终结）之后</p></li><li><p>闭包是词法作用域的体现，内部函数由于作用域链，使得本应在执行完被销毁的外部函数的环境得以保存下来。<br/></p></li></ul></li><li><p>闭包sum</p><ul><li>可推广多括号<br><img src="/static/imgForPosts/JavaScript/ModernCourse/closure2.jpg"><br/></li></ul></li><li><p><strong>变量可见吗？</strong>【不存在的变量与<strong>uninitialized</strong>的变量的区别】</p><ul><li><p>从程序进入代码块时，变量就进入“未初始化状态”<strong>【变量暂时无法使用的区域：死区】</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/closure3.jpg"><br/></p></li><li><p><strong>执行过程中，全局词法环境的变化</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/closure4.jpg"><br/></p></li></ul></li><li><p>【词法环境】</p><ul><li><p><strong>注意词法环境，函数调用时刻</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/closure5.jpg"><br/></p></li><li><p><code>shooter</code>函数在<code>makeArmy（）</code>的词法环境中被<strong>创建</strong>，当army[0]（）被<strong>调用</strong>时，makeArmy已经运行完，i=10；<br><img src="/static/imgForPosts/JavaScript/ModernCourse/closure6.jpg"><br/></p></li><li><p>要解决，我们应该为每个词法环境复制shooter函数创建时i的值 <strong>【let或立即执行函数】</strong><br/></p></li><li><p>1）添加局别迭代变量j【原理相同】<br><img src="/static/imgForPosts/JavaScript/ModernCourse/closure7.jpg"><br/></p></li><li><p>2）或使用for循环。【for 循环在每次迭代中，都会生成一个带有自己的变量 i 的新词法环境】<br><img src="/static/imgForPosts/JavaScript/ModernCourse/closure8.jpg"><br><img src="/static/imgForPosts/JavaScript/ModernCourse/closure9.jpg"></p></li></ul></li></ol><br/><br/><h3 id="调度：setTimeout和setInterval"><a href="#调度：setTimeout和setInterval" class="headerlink" title="调度：setTimeout和setInterval"></a>调度：setTimeout和setInterval</h3><ol><li>setTimeout：将函数推迟到一段时间间隔之后再执行<br/></li><li>clearTimeout：取消调度<br><img src="/static/imgForPosts/JavaScript/ModernCourse/setTimeout1.jpg"><br/></li><li>setInterval：以该时间间隔，重复运行一个函数<br/></li><li><strong>嵌套setTimeout能够精确设置两次执行的延时</strong>，setInterval不能<ul><li><strong>func 函数的实际调用间隔比预设短</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/setTimeout2.jpg"><br><img src="/static/imgForPosts/JavaScript/ModernCourse/setTimeout3.jpg"><br/></li><li><strong>嵌套的 setTimeout 是在<code>调用完成后才执行下一次</code></strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/setTimeout4.jpg"><br><img src="/static/imgForPosts/JavaScript/ModernCourse/setTimeout5.jpg"><br/></li></ul></li><li>应用<ul><li>实现一个server，间隔5秒发送数据请求，若服务器过载，降低请求频率<br><img src="/static/imgForPosts/JavaScript/ModernCourse/setTimeout6.jpg"></li></ul></li></ol><br/><br/><h3 id="函数绑定this-lt-—bind"><a href="#函数绑定this-lt-—bind" class="headerlink" title="函数绑定this&lt;—bind"></a>函数绑定this&lt;—bind</h3><ol><li>丢失this【一旦方法被传递到与对象分开的某个地方—this就丢失】<br/></li><li>可传递参数—<strong>偏函数partial</strong><ul><li><strong>通过绑定已有函数的参数，创建一个新函数</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/bind1.jpg"><br/></li><li>没有context的partial【注意partial传入的是会丢失this的对象方法】<br><img src="/static/imgForPosts/JavaScript/ModernCourse/bind2.jpg"><br/></li><li>通过包装器，返回的函数=user.sayNow，通过call获得相同this指向<br/></li></ul></li><li><strong>不能重绑定</strong><ul><li>.bind返回的绑定函数对象，仅在创建时记忆context和args<br><img src="/static/imgForPosts/JavaScript/ModernCourse/bind3.jpg"><br/></li></ul></li><li><strong>bind后的函数属性</strong><ul><li>undefined。bind 的结果是另一个对象。它并没有 test 属性。<br><img src="/static/imgForPosts/JavaScript/ModernCourse/bind4.jpg"></li></ul></li></ol><br/><br/><h3 id="this的绑定方式"><a href="#this的绑定方式" class="headerlink" title="this的绑定方式"></a>this的绑定方式</h3><ol><li><strong>new&gt;显式&gt;隐式&gt;默认</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/this1.jpg"><br/></li><li>默认：函数直接调用，this全局<br/></li><li>隐式：**.对象，this调用者**<br/></li><li>显式：bind【返回绑定this的新函数】、call、apply【立即执行】<ul><li>bind柯里化，绑定后不可改变。除了new<br/></li></ul></li><li><strong>new绑定：</strong><ul><li>干的4件事<br><img src="/static/imgForPosts/JavaScript/ModernCourse/this2.jpg"></li></ul></li></ol><br/><br/><h3 id="深入理解箭头函数"><a href="#深入理解箭头函数" class="headerlink" title="深入理解箭头函数###"></a>深入理解箭头函数###</h3><ol><li><strong>每一个用function声明的函数</strong>，在<strong>调用时</strong>都会在函数<strong>内创建自己的this</strong>。this一般指调用函数的对象，<strong>若没有，【strict环境下–this为undefined///window】</strong><br/></li><li><code>function声明的函数总是有自己的this。从而遮盖外层作用域中的this</code><br/></li><li><strong>箭头函数没有this</strong>，从外部Environment获取<br/></li><li><strong>箭头函数没有arguments</strong><br/></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS现代教程(2)</title>
      <link href="/2021/05/29/JS%E7%8E%B0%E4%BB%A3%E6%95%99%E7%A8%8B(2)/"/>
      <url>/2021/05/29/JS%E7%8E%B0%E4%BB%A3%E6%95%99%E7%A8%8B(2)/</url>
      
        <content type="html"><![CDATA[<!-- <blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><p><a href="url">articleName</a></p></blockquote> --><!-- hhhh<code></code> --><!-- 见这篇文章：[【三握四挥】](/计网(3)-三握四挥.html) 以post文件夹为起点，也可以设置自身文章连接--><h2 id="数据类型相关"><a href="#数据类型相关" class="headerlink" title="数据类型相关"></a>数据类型相关</h2><h3 id="可迭代（Iterable）对象与类数组（array-like）"><a href="#可迭代（Iterable）对象与类数组（array-like）" class="headerlink" title="可迭代（Iterable）对象与类数组（array-like）###"></a>可迭代（Iterable）对象与类数组（array-like）###</h3><ol><li><p>可迭代</p><ul><li><strong>可迭代都有Symbol.iterator属性</strong></br></li><li>Object.getOwnPropertyDescriptor(Symbol, ‘iterator’)</br></li><li>当用<strong>for…of循环</strong>时，会<strong>调用Symbol.iterator的方法。这个方法必须返回一个迭代器（iterator），即一个有next（）方法的对象</strong></br></li><li>注意：iterator对象与被迭代对象<strong>是分开</strong>的</br></li><li>如果将iterator方法<strong>内置</strong>，返回的是<strong>被迭代对象本身</strong>，就不能在对象上运行两个for…of循环，因为只有一个迭代器<br><img src="/static/imgForPosts/JavaScript/ModernCourse/iterable1.jpg"><br><img src="/static/imgForPosts/JavaScript/ModernCourse/iterable2.jpg"></br></li></ul></li><li><p>类数组</p><ul><li>具有索引和length属性</br></li></ul></li><li><p><strong>Array.from</strong>处理Iterable和array-like<strong>获得数组</strong></p><ul><li>mapFn函数会在<strong>元素被添加到数组前应用</strong>；thisArg：该函数允许设置this<br><img src="/static/imgForPosts/JavaScript/ModernCourse/arrayFrom.jpg"></br></li><li>range例子<br><img src="/static/imgForPosts/JavaScript/ModernCourse/range1.jpg"><br><img src="/static/imgForPosts/JavaScript/ModernCourse/range2.jpg"></li></ul></li></ol><br/><br/><h3 id="Map-and-Set（映射与集合）"><a href="#Map-and-Set（映射与集合）" class="headerlink" title="Map and Set（映射与集合）###"></a>Map and Set（映射与集合）###</h3><ol><li>Map<ul><li><code>[key，value]</code>的集合。<strong>允许任何类型的key</strong></br></li><li>操作：set（key，value），get，has，delete，clear，size</br></li><li>迭代<ul><li>entries为for…of默认<br><img src="/static/imgForPosts/JavaScript/ModernCourse/map1.jpg"></br></li></ul></li><li>forEach【参数三为可选。当前元素所属的数组对象】<br>  <img src="/static/imgForPosts/JavaScript/ModernCourse/map1.jpg"></br></li><li>对象与Map转换<ul><li>Object.entries：从对象创建Map</br></li><li>Object.formEntries：从Map创建对象；【.entries可省略】<br><img src="/static/imgForPosts/JavaScript/ModernCourse/map3.jpg"></br></li></ul></li></ul></li><li>Set<ul><li><strong>value的集合，没有key</strong>。每个value<strong>唯一</strong></br></li><li>操作：<strong>add</strong>，delete，has，clear，size</br></li><li><strong>重复</strong>使用<strong>同一个值</strong>调用<strong>set.add(value)<strong>，</strong>不会发生改变【访客记录】</strong></br></li><li>迭代：for…of，forEach</br></li></ul></li></ol><br/><br/><h3 id="WeakMap-and-WeakSet（弱映射与弱集合）"><a href="#WeakMap-and-WeakSet（弱映射与弱集合）" class="headerlink" title="WeakMap and WeakSet（弱映射与弱集合）###"></a>WeakMap and WeakSet（弱映射与弱集合）###</h3><ol><li><strong>垃圾回收：JS引擎在值可访问（并可能被使用）时将其存储在内存中</strong></br></li><li>WeakMap：仅允许<strong>对象</strong>作为key</br></li><li>WeakSet：仅允许存储<strong>对象</strong></br></li><li>一旦对象通过其它方式无法访问，相关联或对应的value将被删除</br></li><li><strong>它们不支持迭代，因为不知道何时被回收</strong></br></li><li>应用：缓存等<ul><li><strong><a href="https://zh.javascript.info/weakmap-weakset">应用例子</a></strong></li></ul></li></ol><br/><br/><h3 id="通用的迭代：keys，values，entries"><a href="#通用的迭代：keys，values，entries" class="headerlink" title="通用的迭代：keys，values，entries"></a>通用的迭代：keys，values，entries</h3><ol><li>注意区别<br><img src="/static/imgForPosts/JavaScript/ModernCourse/normalIterable1.jpg"></br></li><li>忽略Symbol属性<br><img src="/static/imgForPosts/JavaScript/ModernCourse/normalIterable2.jpg"></li></ol><br/><br/><h3 id="常用数组方法"><a href="#常用数组方法" class="headerlink" title="常用数组方法"></a>常用数组方法</h3><ol><li>map&amp;filter过滤器<ul><li>map返回调用函数处理后的数组</br></li><li>filter返回调用函数<strong>处理判断后为true</strong>的数组</br></li></ul></li><li>forEach：每个元素执行一次提供的函数，不返回</br></li><li>reduce：arr.reduce（callback(total,currentVal,arr),initialVal）<ul><li>默认total=arr[0],currentVal=arr[1],arr为调用reduce的数组、可选</li><li><strong>initialVal修改total的默认值，则currentVal=arr[0]</strong></br></li></ul></li><li>sort：<strong>接收函数，函数参数为a,b两个比较元素</strong>。a&gt;b，return 1，则a在b之后</br></li><li>concat：连接数组，浅拷贝</br></li><li>slice：<strong>不修改原数组，浅拷贝【begin，end）</strong></br></li><li>splice：<strong>修改原数组，数组形式返回被修改内容</strong><ul><li>start位，删除个数，替换元素列表<br><img src="/static/imgForPosts/JavaScript/ModernCourse/array.jpg"></li></ul></li></ol><br/><br/><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ol><li>对任何可迭代对象适用：对象、数组、字符串</br></li><li>数组模型<ul><li>可嵌套<br><img src="/static/imgForPosts/JavaScript/ModernCourse/deconstr1.jpg"></br></li><li>可忽略<br><img src="/static/imgForPosts/JavaScript/ModernCourse/deconstr2.jpg"></br></li><li>剩余运算符<br><img src="/static/imgForPosts/JavaScript/ModernCourse/deconstr3.jpg"></br></li></ul></li><li>对象模型<br> <img src="/static/imgForPosts/JavaScript/ModernCourse/deconstr4.jpg"></li></ol><br/><br/><h3 id="JSON方法"><a href="#JSON方法" class="headerlink" title="JSON方法"></a>JSON方法</h3><ul><li>JSON.stringify【当对象中有toJSON方法，自动调用，类似toString】</br></li><li>JSON.parse</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS现代教程(1)</title>
      <link href="/2021/05/15/JS%E7%8E%B0%E4%BB%A3%E6%95%99%E7%A8%8B(1)/"/>
      <url>/2021/05/15/JS%E7%8E%B0%E4%BB%A3%E6%95%99%E7%A8%8B(1)/</url>
      
        <content type="html"><![CDATA[<!-- <blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><p><a href="url">articleName</a></p></blockquote> --><!-- hhhh<code></code> --><!-- 见这篇文章：[【三握四挥】](/计网(3)-三握四挥.html) 以post文件夹为起点，也可以设置自身文章连接--><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>JS可在任意搭载了JS引擎的设备执行【浏览器、服务端等】</br></li><li>引擎有很多种：Chrome/Opera【V8引擎】</br></li><li><strong>引擎如何工作？</strong><ul><li>基本原理：引擎<strong>解析</strong>脚本—-&gt;引擎将脚本<strong>编译</strong>为机器语言—-&gt;机器代码快速<strong>执行</strong></br></li><li>引擎会在流程每个阶段进行优化</br></li><li>甚至可以在脚本运行时监视它，分析数据流，进一步优化</br></li></ul></li><li>浏览器中的JS能做什么？<ul><li><strong>JS不提供对内存、CPU的底层访问</strong></br></li><li>JS能力很大程度取决于运行环境<ul><li>如Node.js支持读写任意文件、网络请求等函数</br></li></ul></li><li><strong>浏览器中的JS—网页操作、用户交互、Web服务器相关</strong><ul><li>编写网页</br></li><li>响应用户操作：鼠标、按键等</br></li><li><strong>向服务器发送请求，下载【Ajax】/上传【Comet】文件</strong></br></li><li>获取、设置cookie</br></li><li>保存客户端数据【本地存储】</br></li></ul></li></ul></li><li>浏览器JS<strong>不能做什么</strong>？<ul><li><strong>为了信息安全，防止恶意网页窃取信息</strong>—–&gt;浏览器JS是被限制的</br></li><li><strong>JS不提供对内存、CPU的底层访问【允许部分文件相关操作，但需要用户拖拽等行为】</strong></br></li><li>不同标签页/窗口互不了解：两个标签页不是同一个网站 <strong>【域名、协议和端口相同】</strong>， <strong>都不能互相通信</strong>—–&gt;<strong>【同源策略】</strong></li></ul></li></ol><br/><br/><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li>use strict【放在最顶部】<ul><li>JS为了兼容旧代码，新ES的特性和修改大部分默认不生效，strict激活</br></li></ul></li><li><strong>反引号<code>``</code>，模板字符串</strong><ul><li>允许将变量和表达式包装在<code>$&#123;...&#125;</code>中，将它们<strong>嵌入到字符串</strong>中</br></li><li><code>$&#123;...&#125;</code>内的表达式**会被计算##<br><img src="/static/imgForPosts/JavaScript/ModernCourse/Quotation1.jpg"><br><img src="/static/imgForPosts/JavaScript/ModernCourse/Quotation2.jpg"></br></li></ul></li><li>数据类型—-<strong>8种【JS运算符顺序：左—&gt;右】</strong><ul><li>7种基本类型：Number、String、Boolean、null、undefined、Symbol、bigInt<ul><li>null：仅代表一个未知的特殊值 <strong>【let age=null；】</strong></br></li><li>undefined：含义—-<strong>未被赋值【let age；alert（age）】</strong></br></li><li><strong>symbol</strong>：用于<strong>创建对象的唯一标识符</strong></br></li></ul></li><li>1种引用类型：<strong>object</strong><ul><li>包含：Data、function、Array等</br></li></ul></li><li><strong>查询类型</strong>【注意 null—-object。函数–function】—早期错误<ul><li>typeof</br></li></ul></li><li>类型转换<ul><li>显式转换<br><img src="/static/imgForPosts/JavaScript/ModernCourse/Transfer1.jpg"></br></li><li>隐式转换<br><img src="/static/imgForPosts/JavaScript/ModernCourse/Transfer2.jpg"></br></li><li>具体类型规则<ul><li>undefined—NaN</br></li><li>string【去首尾部空格，<strong>纯数字字符串所含数字</strong>】<code>【Number("123z")】----->undefined</code></br></li></ul></li></ul></li><li><strong>值的比较</strong><ul><li>字符串：<strong>字典Unicode比较</strong>，小写更大</br></li><li><code>null和undefined</code>：null == undefined，true；null === undefined，false。<strong>【绝对等于时，检查类型】</strong></br></li><li><strong>null vs 0</strong><ul><li>普通比较符中：null转为0； <code>相等性检查中：null不转换</code><br><img src="/static/imgForPosts/JavaScript/ModernCourse/Compare1.jpg"></br></li></ul></li><li><strong>undefined vs 0</strong><ul><li>（1）（2）-转换为NaN；（3）【同红色null】<br><img src="/static/imgForPosts/JavaScript/ModernCourse/Compare2.jpg"></li></ul></li></ul></li></ul></li></ol><br/><br/><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol><li><p>构造</p><ul><li>字面量的语法<br><img src="/static/imgForPosts/JavaScript/ModernCourse/object1.jpg"></br></li></ul></li><li><p>方括号与计算属性</p><ul><li>点符号不能类似方式使用<br><img src="/static/imgForPosts/JavaScript/ModernCourse/object2.jpg"></br></li></ul></li><li><p>计算属性</p><ul><li><code>[fruit]</code>含义：属性名应该从fruit变量中获取<br><img src="/static/imgForPosts/JavaScript/ModernCourse/object3.jpg"></br></li></ul></li><li><p>属性存在？—&gt;in操作符；删除属性：delete</p><ul><li><strong>属性存在，但值undefined</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/object4.jpg"></br></li></ul></li><li><p><strong>for…in遍历对象所有key</strong></p><ul><li>包括原型链上的<br><img src="/static/imgForPosts/JavaScript/ModernCourse/object5.jpg"></br></li></ul></li><li><p><strong>引用与复制【对象为什么叫引用类型？】</strong></p><ul><li><p>原始类型中：</p><ul><li>我们拥有了两个<strong>独立的</strong>，但<strong>指向不同内存</strong>存储的值相同的<strong>变量</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/object6.jpg"><br><img src="/static/imgForPosts/JavaScript/ModernCourse/object7.jpg"></br></li></ul></li><li><p>对象变量中：</p><ul><li>对象变量相当于写着变量名的信<br>  <img src="/static/imgForPosts/JavaScript/ModernCourse/object8.jpg"><br>  <img src="/static/imgForPosts/JavaScript/ModernCourse/object9.jpg"></br></li></ul></li></ul></li><li><p><strong>比较【仅当引用同一对象时相等】</strong></br></p></li><li><p><strong>克隆与合并，Object.assign</strong></p><ul><li><p>遍历key，<strong>复制对象本身</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/object10.jpg"><br><img src="/static/imgForPosts/JavaScript/ModernCourse/object11.jpg"></br></p></li><li><p><strong>深层克隆【当对象为object时，又有浅拷贝了】</strong></p><ul><li>需要递归，检查每个user[key]的值是否为object，复制它的结构</br></li><li>现成轮子：lodash库中的_.cloneDeep(obj)</br></li></ul></li></ul></li><li><p>可选链 <code>？.</code><strong>【用于安全访问嵌套属性，可读、删，不能写入】</strong></p><ul><li>语法<ul><li><code>obj?.prop; obj.[prop]; </code> — <strong>存在返回，否则undefined</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/object12.jpg"></br></li><li><code>obj.method?.()</code> — <strong>存在则调用，否则返回undefined</strong></li></ul></li></ul></li><li><p><strong>Symbol类型标识符</strong></p><ul><li><p>对象的key只能是字符串和Symbol</br></p></li><li><p>创建：<strong>let id=Symbol(‘id’); description属性</strong></br></p></li><li><p>Symbol<strong>总是不同的值</strong>，即使description相同</p></li><li><p>若<strong>希望同名的Symbol相等</strong>，应该使用<strong>全局注册表.for【反向调用.keyFor】</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/object13.jpg"></br></p></li><li><p><strong>应用场景</strong></p><ul><li><strong>“隐藏”对象属性</strong>：对于第三方的对象user，我们不应该添加额外字段，采用Symbol，不会被意外访问到。<strong>【不参与keys，for..in遍历】</strong><br><img src="/static/imgForPosts/JavaScript/ModernCourse/object14.jpg"></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
