<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式-2</title>
      <link href="/2021/08/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-2/"/>
      <url>/2021/08/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-2/</url>
      
        <content type="html"><![CDATA[<!-- 注意，那些话花括号只是为了说明，要去掉！ --><!-- <blockquote><footer><strong>[ author [</strong><cite>source]] [link] [linkTitle]</cite></footer></blockquote><div class="note info flat"><p>点击可查看大图</p></div><figure class="highlight plaintext"><figcaption><span>[title] [lang:language] [url] [link text]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code snippet</span><br></pre></td></tr></table></figure> --><blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><!-- [articleName](https://juejin.cn/post/6969018138591494158) --></blockquote><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><blockquote><p>这部分有4个方面<br>1.<strong>分组</strong><br>2.<strong>回溯引用</strong><br>3.<strong>前后预先查找（零宽度断言）</strong><br>4.贪婪与懒惰匹配</p></blockquote><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>采用<code>( )</code>进行匹配分组<br><br></p><h2 id="回溯引用"><a href="#回溯引用" class="headerlink" title="回溯引用"></a>回溯引用</h2><p>简而言之，就是在子表达式匹配结果的基础上，再次进行匹配</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>使用方式如下：<br><code>/1</code>,<code>/2</code><br>分别表示引用前面的 <strong>第1、2个</strong> 子表达式<br><code>/0</code>代表整个Regx </p><div class="note flat"><p>/(a)(b)\1/<br>描述：相当于匹配aba字符串<br>结果：<br>abc|abbc|<strong>aba</strong></p></div><br><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>使用方式类似：<br><code>$1</code>,<code>$2</code><br>分别表示引用前面的<strong>第1、2个子表达式的结果</strong><br><code>$0</code>或<code>$&</code>代表整个Regx匹配结果</p><div class="note flat"><p>需要注意的是：<br>直接用<strong>newSubStr</strong>替换时，整体应该用 <strong>$&amp;</strong> 表示<br>使用<strong>function</strong>时，应该使用 <strong>$0</strong></p></div><p>字符串替换函数,该函数返回一个新字符串<br>str.replace(regexp|substr, <strong>newSubStr|function</strong>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&quot;18:78:45:222&quot;</span></span><br><span class="line"><span class="comment">//匹配该特定时间戳</span></span><br><span class="line"><span class="keyword">let</span> reg=<span class="regexp">/^(.&#123;5,8&#125;):(.*)$/g</span></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="keyword">let</span> result</span><br><span class="line">str.replace(reg, <span class="function">(<span class="params">$<span class="number">0</span></span>)=&gt;</span>&#123;</span><br><span class="line">    result=$<span class="number">0</span>+<span class="string">&#x27;111&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><br><h3 id="非捕获正则"><a href="#非捕获正则" class="headerlink" title="非捕获正则"></a>非捕获正则</h3><p>如果不想子字符串被引用的话，我们可以<strong>让它不被捕获</strong><br>那么它就不会单独出现在结果组中，避免内存的浪费</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">let</span> result=str.replace(<span class="regexp">/(ab)(?:c)/g</span>,<span class="string">&#x27;$&amp;:$1:&amp;$2:&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">//abc:ab:$2</span></span><br><span class="line"><span class="comment">//c并没有被单独捕获储存为“$2”的值，但是整体的结果组“$&amp;”中还是有它的</span></span><br></pre></td></tr></table></figure><br><h2 id="前后预查（零宽度断言）（Lookaround）"><a href="#前后预查（零宽度断言）（Lookaround）" class="headerlink" title="前后预查（零宽度断言）（Lookaround）"></a>前后预查（零宽度断言）（Lookaround）</h2><p>包括：</p><ol><li>前向查找（Lookahead）:描述<strong>目标前面</strong>的内容</li><li>后向查找（Lookbehind）：描述<strong>目标后面</strong>的内容</li></ol><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>Lookaround,观察周边的环境</p><p>我们可以通过描述目标内容的<strong>前后内容</strong>，来匹配它<br>在后文，我称这种内容为<strong>环境内容</strong><br>简单来说，这就是<strong>相对定位</strong>的一种方式</p><p>断言：一个为真的描述<br>零宽度：描述中的<strong>环境内容</strong>实际并<strong>不作为匹配结果</strong>返回，即不会被捕获。<br>【在语文上，该描述就是目标内容的定语】</p><!-- ### 前向查找 (Lookahead)1. （正）前向查找<div class="note flat"><p>/\w+(?=ish)/<br>    描述：查找&gt;=0个单词字符。这些字符组成的字符串的后缀为“ish”<br>    即【查找后缀为“ish”的单词的前缀】<br>    结果：<strong>fool</strong>ish and <strong>child</strong>ish.</p></div><ol start="2"><li>负前向查找<div class="note flat"><p>/\b(\w(?!ish))+\b/<br>    描述：查找&gt;0个后缀不为“ish”的单词字符。这些字符组成被单词边界包裹的字符串<br>    即【查找后缀不为“ish”的单词】<br>    结果：foolish <strong>and</strong> childish.</p></div></li></ol><h3 id="后向查找-Lookbehind"><a href="#后向查找-Lookbehind" class="headerlink" title="后向查找 (Lookbehind)"></a>后向查找 (Lookbehind)</h3><ol><li>（正）后向查找<div class="note flat"><p>/(?&lt;=fool)\w+\b/<br>    描述：查找&gt;=0个单词字符。这些字符组成的字符串的前缀为“fool”，它的后面为单词边界<br>    即【查找前缀为“fool”的单词的后缀】<br>    结果：fool<strong>ish</strong> and childish.</p></div></li><li>负后向查找<div class="note flat"><p>/\b((?&lt;=fool)\w)+\b/<br>    描述：查找&gt;=0个前缀不为“fool”的单词字符，这些字符组成被单词边界包裹的字符串<br>    即【查找前缀不为“fool”的单词】<br>    结果：fool<strong>ish</strong> and childish.</p></div> --><br></li></ol><h3 id="正-查找"><a href="#正-查找" class="headerlink" title="(正)查找"></a>(正)查找</h3><p>对描述的前、后内容持<strong>肯定</strong>态度</p><ol><li><p>(正)前向查找</p><div class="note flat"><p>/\w+(?=ish)/<br>    描述：查找&gt;=1个单词字符。这些字符组成的字符串的后缀为“ish”<br>    即【查找后缀为“ish”的单词的前缀】<br>    结果：<strong>fool</strong>ish and <strong>child</strong>ish.</p></div></li><li><p>(正)后向查找</p><div class="note flat"><p>/(?&lt;=fool)\w+\b/<br>    描述：查找&gt;=1个单词字符。这些字符组成的字符串的前缀为“fool”，它的后面为单词边界<br>    即【查找前缀为“fool”的单词的后缀】<br>    结果：fool<strong>ish</strong> and childish.</p></div><br></li></ol><h3 id="负查找"><a href="#负查找" class="headerlink" title="负查找"></a>负查找</h3><p>对描述的环境内容持<strong>否定</strong>态度</p><ol><li><p>负前向查找</p><div class="note flat"><p>/\b(\w(?!ish))+\b/<br>    描述：查找&gt;1个后缀<strong>【不】</strong>为“ish”的单词字符。这些字符组成被单词边界包裹的字符串<br>    即【查找后缀不为“ish”的单词】<br>    结果：foolish <strong>and</strong> childish.</p></div></li><li><p>负后向查找</p><div class="note flat"><p>/\b((?&lt;=fool)\w)+\b/<br>    描述：查找&gt;=1个前缀<strong>【不】</strong>为“fool”的单词字符，这些字符组成被单词边界包裹的字符串<br>    即【查找前缀不为“fool”的单词】<br>    结果：foolish <strong>and</strong> <strong>childish</strong>.</p></div></li></ol><div class="note warning flat"><p>在<code>JavaScirpt</code>中，ES2018之前并不支持<strong>后向查找</strong><br>可以通过<strong>字符串翻转</strong>来间接完成</p></div><br><h2 id="贪婪与懒惰匹配-（Greedy-vs-Lazy-matching）"><a href="#贪婪与懒惰匹配-（Greedy-vs-Lazy-matching）" class="headerlink" title="贪婪与懒惰匹配 （Greedy vs Lazy matching）"></a>贪婪与懒惰匹配 （Greedy vs Lazy matching）</h2><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>Regx<strong>默认</strong>采用贪婪匹配：<br>匹配<strong>尽可能长</strong>的字符串</p><div class="note flat"><p>/(.*at)/<br>    描述：贪婪查找&gt;=0个除换行符之外的任意字符。这些字符组成的字符串后缀为“at”<br>    结果：<strong>The fat cat sat on the mat</strong>. </p></div><h3 id="惰性匹配"><a href="#惰性匹配" class="headerlink" title="惰性匹配"></a>惰性匹配</h3><p>我们可以采用来转为Lazy模式<br>注意区分数量指定中的<code>?</code></p><div class="note flat"><p>/(.*?at)/<br>    描述：惰性查找&gt;=0个除换行符之外的任意字符。这些字符组成的字符串后缀为“at”<br>    结果：<strong>The fat</strong> cat sat on the mat. </p></div><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基础篇掌握练习，进阶篇主要是要掌握匹配描述的思想，实际上这些思想我们在学习其他工具、学科都已经接触、熟悉过了<br>Regx是门工具语言，我们就是要学会怎么有逻辑地把自己的意思表达出来</p><p>想练习巩固的可以自行选择基础篇的开头推荐的网站<br>希望对大家有所帮助~<br>也欢迎大家畅所欲言~</p><div class="note flat"><p>参考文章：</p><ol><li><a href="https://juejin.cn/post/6844903845227659271#heading-2">正则表达式不用背</a></li><li><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md#learn-regex">Learn-Regex</a></li></ol></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> Regx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式-1</title>
      <link href="/2021/08/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-1/"/>
      <url>/2021/08/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-1/</url>
      
        <content type="html"><![CDATA[<!-- 注意，那些话花括号只是为了说明，要去掉！ --><!-- <blockquote><footer><strong>[ author [</strong><cite>source]] [link] [linkTitle]</cite></footer></blockquote><div class="note info flat"><p>点击可查看大图</p></div><figure class="highlight plaintext"><figcaption><span>[title] [lang:language] [url] [link text]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code snippet</span><br></pre></td></tr></table></figure> --><!-- 直接用这个``` javascript``` --><!-- 指定语言高亮<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>  --><!-- <code>可用于显示有背景色的文字\b(\w+)\s\1</code> --><blockquote><p>写作不易，未经作者允许禁止以任何形式转载!<br>如果觉得文章不错，欢迎关注、点赞和分享！</p><!-- [articleName](https://juejin.cn/post/6969018138591494158) --></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习一门工具时，我认为要了解以下几点：</p><ol><li>它是什么？–or–它被创造出来是为了什么目的？</li><li>它的基本组成与基础用法</li><li>它的进阶用法</li></ol><p>接下来，我会以此为大概脉络，阐述我认知中的正则表达式<br>如果有什么错误、想法，敬请各位畅所欲言！感谢~</p><p>推荐选择Regex101作为起步：</p><ul><li><a href="https://regex101.com/">Regex101</a><br>【显示匹配结果，对表达式作解释。登录后可进行quiz小测。设置中默认全局搜索&amp;多行模式，见（定位与搜索）-（标志）】</li><li><a href="https://regexper.com/">regexper</a><br>【可视化显示表达式】</li><li><a href="https://tool.oschina.net/regex#">osChina</a><br>【右侧有常用的Regx示例】<br></li></ul><h1 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h1><p>正则表达式(<strong>Regular Expression</strong>，简称Regx)，从命名我们不难猜到，它是一种<strong>描述</strong>某种<strong>规则</strong>的表达式。通过自定义规则，我们可以用它来实现字符串检索、替换的功能</p><p>据言，正则表达式起源于<strong>描述神经网络</strong>的数学模型。联系神经网络相关的知识，有助于我们更深刻地理解它的实现原理，感兴趣的同学可以深入研究</p><h1 id="基本组成与基础用法"><a href="#基本组成与基础用法" class="headerlink" title="基本组成与基础用法"></a>基本组成与基础用法</h1><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p>正则表达式的基本组成元素：<strong>普通字符与元字符</strong>(metaCharacters)。<br>普通字符：包括大小写字母和数字<br>元字符：被规定具有<strong>特殊含义</strong>的字符</p><blockquote><p>了解了正则表达式的基本组成之后<br>我们将结合一些简单的例子，边学边做，循序渐进</p></blockquote><br><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>在这个章节，我们会逐渐接触到一个个的<strong>元字符</strong><br>而在文章的末尾，我会附上文章涉及到的<strong>元字符</strong>等表格，方便大家回忆、总结以及练习</p><p>现在开始，想象我们是一个<strong>发号施令的指挥者</strong>，我们将向<strong>执行者</strong>，利用Regx这门语言工具描述一个规则，让他去为我们找到想要的字符~<br><br></p><h3 id="【明确的】单字符匹配"><a href="#【明确的】单字符匹配" class="headerlink" title="【明确的】单字符匹配"></a>【明确的】单字符匹配</h3><p>我们非常直白描述了：我们需要匹配<strong>一个普通字符a</strong></p><div class="note flat"><p>/a/<br>结果：<br>A <strong>a</strong>pple for <strong>a</strong> m<strong>a</strong>n.</p></div><p>不难发现，正则表达式是 <strong>【大小写敏感】</strong> 的<br><br></p><p>这里，我们可以提出一个问题：<br>普通字符，我们可以匹配了，那么如果我要匹配<strong>一个元字符</strong>怎么办呢？<br>这就需要请出我们的转义元字符<code>\</code>了。顾名思义，用它告诉执行者，后续的字符舍弃其<strong>本身含义</strong>，赋予<strong>另一种含义</strong></p><div class="note flat"><p>/\+/<br>描述：查找元字符+<br>结果：<br>1 <strong>+</strong> 1=2</p></div>  <br><p>转义字符，相信大家并不陌生。<br>上面我们用它将特殊字符 <code>+</code> 描述为普通字符<br>那么，如果我们用转义字符描述<strong>某些</strong>普通字符，会发生什么呢？</p><div class="note flat"><p>/\n/<br>结果：<br>A apple for a man.<strong>我是换行符\n</strong><br>Funny day.</p></div><p>这里的 <code>\n</code>就是字符编码中被赋予特殊意义的转义字符了<br><br></p><!-- 表格必须上一行为【空行】 --><!-- 利用中间的冒号，实现左、右、中对齐 --><p>类似的常见转义特殊字符有：</p><table><thead><tr><th align="left">特殊字符</th><th align="left">表达式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">换行符</td><td align="left">\n</td><td align="left"><strong>n</strong>ew line</td></tr><tr><td align="left">回车符</td><td align="left">\r</td><td align="left"><strong>r</strong>etutn</td></tr><tr><td align="left">空格符</td><td align="left">\s</td><td align="left"><strong>s</strong>pace</td></tr><tr><td align="left">水平制表符</td><td align="left">\t</td><td align="left"><strong>t</strong>ab</td></tr><tr><td align="left">垂直制表符</td><td align="left">\v</td><td align="left"><strong>v</strong>ertical</td></tr><tr><td align="left">换页符</td><td align="left">\f</td><td align="left"><strong>f</strong>rom feed</td></tr></tbody></table><br><h3 id="多字符匹配"><a href="#多字符匹配" class="headerlink" title="多字符匹配"></a>多字符匹配</h3><blockquote><p>现在，我们开始学习怎么向执行者描述多个字符</p></blockquote><p>最简单的。<strong>明确地</strong>描述一个<strong>连续的abc子串</strong></p><div class="note flat"><p>/abc/<br>结果：<br>I’ m <strong>abc</strong>君.a&amp;bc</p></div><br><p>元字符<code>( )</code>,定义<strong>子串集合</strong>，匹配该子串</p><div class="note flat"><p>/(abc)/<br>结果：<br>I’ m <strong>abc</strong>君.a&amp;bc</p></div><br><p>元字符<code>.</code>，代表除<strong>换行符之外</strong>的<strong>任意字符</strong></p><div class="note flat"><p>/. /<br>结果：<br><strong>A apple for a man.</strong> 我是换行符<br><strong>Funny day.</strong></p></div><br><p>元字符<code>[ ]</code>，定义<strong>字符种类</strong>,匹配这类字符<br>实际上，一些常见的字符种类，已经被定义好了。我会在表格中附上</p><div class="note flat"><p>/[a-c]/<br>结果：<br>I’ m <strong>abc</strong>君.<strong>a</strong>&amp;<strong>b</strong>&amp;<strong>c</strong></p></div><br><p>元字符<code>[^ ]</code>，<strong>否定的</strong>字符集合，将其<strong>除外</strong><br>需要注意的是，<code>*</code><strong>不在[]中</strong>时，含义是不同的。后续会提到</p><div class="note flat"><p>/[a-c]/<br>结果：<br><strong>I’ m</strong> abc <strong>君.</strong> a <strong>&amp;</strong> b <strong>&amp;</strong> c</p></div><br><p>他们的共同点是：描述了一个有序或无序的字符串集合。<br>理所当然的，这个集合我们又可以看作<strong>一个自定义的字符</strong>，从而进行更复杂的规则描述<br><br></p><h3 id="字符重复数量指定"><a href="#字符重复数量指定" class="headerlink" title="字符重复数量指定"></a>字符重复数量指定</h3><blockquote><p>前面，我们学会了怎么分类。<br>为了编写的简便，我们接下来学习怎么<strong>指定字符重复次数</strong></p></blockquote><br><p>元字符<code>?</code>，0或1个,<code>?</code>之前的字符</p><div class="note flat"><p>/ab?c/<br>结果：<br><strong>abc</strong>|abbc|<strong>ac</strong></p></div><br><p>元字符 <code>*</code>，&gt;=0个 </p><div class="note flat"><p>/ab*c/<br>结果：<br><strong>abc</strong>|<strong>abbc</strong>|<strong>ac</strong></p></div><br><p>元字符<code>+</code>，&gt;=1个</p><div class="note flat"><p>/ab+c/<br>结果：<br><strong>abc</strong>|<strong>abbc</strong>|ac</p></div><br><p>元字符<code>&#123;min,max&#125;</code>,指定数量范围<br>注意：用法为<code>&#123;min,&#125;</code>、<code>&#123;min,max&#125;</code>、<code>&#123;定量&#125;</code>【为闭合区间】</p><div class="note flat"><p>/ab{1,}c/<br>结果：<br><strong>abc</strong>|<strong>abbc</strong>|ac</p></div><br><h3 id="定位与修正"><a href="#定位与修正" class="headerlink" title="定位与修正"></a>定位与修正</h3><blockquote><p>上面我们已经了解了怎么描述我们要的<strong>字符的样子</strong></p><p>接下来，我们进入较为具体的应用场景：</p><ul><li>在<strong>文本</strong>中描述匹配字符的<strong>位置</strong></li><li>以及对匹配<strong>结果</strong>进行<strong>修正</strong></li></ul><p>内容包括以下3点：</p><ol><li>单词边界【】</li><li>字符串边界</li><li>标志</li></ol></blockquote><br><h4 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h4><p>Regx：<code>\b</code> —&gt;<strong>b</strong>oundary</p><div class="note flat"><p>/\bour\b/<br>结果：<br><strong>our</strong> hotel during happy hours</p></div><br><h4 id="非单词边界"><a href="#非单词边界" class="headerlink" title="非单词边界"></a>非单词边界</h4><p>Regx：<code>\B</code></p><div class="note flat"><p>/\Bour\B/<br>结果：<br>our hotel during happy h<strong>our</strong>s</p></div><br><h4 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h4><p>Regx：<code>^</code> —-&gt;匹配字符串首开始检索</p><div class="note flat"><p>/^me/<br>结果：<br><strong>me</strong> and you and me</p></div><p>Regx： <code>$</code> —-&gt; 匹配字符串尾开始检索</p><div class="note flat"><p>/me$/<br>结果：<br>me and you and <strong>me</strong></p></div><br><h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><p>标志（模式<strong>修正</strong>符），顾名思义，用于<strong>修正</strong>模式匹配的<strong>结果</strong>。可以任意组合。</p><p>标志：<code>m</code> —-&gt; <strong>m</strong>utiline,多行模式<br>前面提到的<code>^</code>和<code>$</code>用于指定检索起点<strong>字符串</strong>首、末<br>当设置了标志<code>m</code>，<code>$</code>也匹配字符<code>\n</code>和<code>\r</code></p><p>所以我们想Regx在<strong>每行</strong>的首末生效，就需要用到<code>m</code></p><div class="note flat"><p><strong>“/end(.)?$/”</strong><br>描述：匹配<strong>字符串末尾</strong>的“end+后面可选除换行符的任意字符”<br>结果：<br>How do  you friend<br>intend<br>to spend<br>the week<strong>end.</strong></p><p>多行模式：<br><strong>“/end(.)?$/m”</strong><br>描述：匹配<strong>每行行尾</strong>的“end+后面可选除换行符的任意字符”<br>结果：<br>How do  you fri<strong>end</strong><br>int<strong>end</strong><br>to sp<strong>end</strong><br>the week<strong>end.</strong></p><p>其它标志的用法相同</p></div><p>标志：<strong>i</strong> —-&gt; <strong>i</strong>gnore case，忽略大小写</p><p>标志：<strong>g</strong> —-&gt; <strong>g</strong>lobal search，全局搜索<br>需要明确的是：<br>非全局搜索时，Regx匹配<strong>一次</strong>，就会停止并返回结果<br>全局搜索，则会执行<strong>多次</strong>匹配，返回所有结果<br><br></p><blockquote><p>感谢你能看到这里，希望对你有所帮助<br>基础的都基本讲完了，相信写些简单的字符匹配，大家也能心中有数了</p><p>Regx中，<strong>有些常用的字符集匹配是已经集成的了</strong>，我会在每篇文章结尾附上表格</p><p>下一篇将继续探讨如何处理更复杂的Regx</p></blockquote><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="常见转义字符"><a href="#常见转义字符" class="headerlink" title="常见转义字符"></a>常见转义字符</h2><table><thead><tr><th align="left">特殊字符</th><th align="left">表达式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">换行符</td><td align="left">\n</td><td align="left"><strong>n</strong>ew line</td></tr><tr><td align="left">回车符</td><td align="left">\r</td><td align="left"><strong>r</strong>etutn</td></tr><tr><td align="left">空格符</td><td align="left">\s</td><td align="left"><strong>s</strong>pace</td></tr><tr><td align="left">水平制表符</td><td align="left">\t</td><td align="left"><strong>t</strong>ab</td></tr><tr><td align="left">垂直制表符</td><td align="left">\v</td><td align="left"><strong>v</strong>ertical</td></tr><tr><td align="left">换页符</td><td align="left">\f</td><td align="left"><strong>f</strong>rom feed</td></tr></tbody></table><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th align="left">元字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义字符</td></tr><tr><td align="left">.</td><td align="left">代表除了换行符的字符</td></tr><tr><td align="left">(xyz)</td><td align="left">定义字符组。匹配xyz整个子串</td></tr><tr><td align="left">[ ]</td><td align="left">定义字符种类。匹配种类任意字符</td></tr><tr><td align="left">[^]</td><td align="left">定义否定除外的字符种类</td></tr><tr><td align="left">？</td><td align="left">0或1个前面的字符</td></tr><tr><td align="left">*</td><td align="left">&gt;=0个前面的字符</td></tr><tr><td align="left">+</td><td align="left">&gt;=1个前面的字符</td></tr><tr><td align="left">{min,max}</td><td align="left">闭合区间匹配字符数量指定：{min,}{定量}{min,max}</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"><strong>|</strong></td><td align="left">逻辑或，匹配前或后的字符</td></tr><tr><td align="left">[^regex]或!</td><td align="left">逻辑非，否定</td></tr></tbody></table><h2 id="定位相关字符"><a href="#定位相关字符" class="headerlink" title="定位相关字符"></a>定位相关字符</h2><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\b</td><td align="left">单词边界</td></tr><tr><td align="left">\B</td><td align="left">非单词边界</td></tr><tr><td align="left">^</td><td align="left">字符串首开始匹配</td></tr><tr><td align="left">$</td><td align="left">字符串末开始匹配</td></tr><tr><td align="left">m</td><td align="left">标志<strong>m</strong>utiline，多行模式</td></tr><tr><td align="left">i</td><td align="left">标志<strong>i</strong>gnore case，忽略大小写</td></tr><tr><td align="left">g</td><td align="left">标志<strong>g</strong>lobal search，全局搜索</td></tr></tbody></table><h2 id="常用的集成Regx"><a href="#常用的集成Regx" class="headerlink" title="常用的集成Regx"></a>常用的集成Regx</h2><table><thead><tr><th align="left">匹配区间</th><th align="left">Regx</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">除了换行符的字符</td><td align="left"><strong>.</strong></td><td align="left">一生二，二生三，三生万物</td></tr><tr><td align="left">数字，[0-9]</td><td align="left">\d</td><td align="left"><strong>d</strong>igit</td></tr><tr><td align="left">非数字，[^/d]</td><td align="left">\D</td><td align="left">not digit</td></tr><tr><td align="left">数字+字母+下划线，[a-zA-Z0-9_]</td><td align="left">\w</td><td align="left"><strong>w</strong>ord</td></tr><tr><td align="left">[^/w]</td><td align="left">\W</td><td align="left">not word</td></tr><tr><td align="left">所有空白字符【空格、制表、换页、换行、DOS终止符】[\t\n\f\t\p{Z}]</td><td align="left">\s</td><td align="left"><strong>s</strong>pace</td></tr><tr><td align="left">[^\s]</td><td align="left">\S</td><td align="left">not space</td></tr></tbody></table><h2 id="回溯查找"><a href="#回溯查找" class="headerlink" title="回溯查找"></a>回溯查找</h2><table><thead><tr><th align="left">作用</th><th align="left">Regx</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">引用</td><td align="left">\0,\1</td><td align="left">转义数字</td></tr><tr><td align="left">替换</td><td align="left">$0,$&amp;,$1</td><td align="left">结果整体：function中为$0,str中为$&amp;</td></tr><tr><td align="left">非捕获组</td><td align="left">(?:)</td><td align="left">不被单独捕获为结果</td></tr><tr><td align="left">前向查找</td><td align="left">Regx(?=content)</td><td align="left">?目标内容，=对环境内容持肯定态度</td></tr><tr><td align="left">后向查找</td><td align="left">(?&lt;=content)Regx</td><td align="left">?目标内容，&lt;目标小于content【目标在后方，向后找】，=对环境内容肯定态度</td></tr><tr><td align="left">负查找</td><td align="left">对应方向查找“=”换为“!”</td><td align="left">!对环境内容持否定态度</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> Regx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
